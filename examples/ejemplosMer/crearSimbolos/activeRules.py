import copy, sys, cPickle
sys.path.append('/usr/local/share/agm/')
from AGGL import *
from agglplanner import *

def computeMaxScore(a, b, maxScore):
	s = 0
	for i in a: s+=i
	for i in b: s+=i
	if s > maxScore: return s
	return maxScore

def getNewIdForSymbol(node):
	m = 1
	for k in node.graph.nodes:
			if int(node.graph.nodes[k].name) >= m:
				m = int(node.graph.nodes[k].name)+1
	return m

lastNodeId = 0

class RuleSet(object):
	def __init__(self):
		object.__init__(self)

# Up to this point, all the code has been generated by the generateAGGLPlanerCode.py file

	def getRules(self):
		mapping = dict()
		mapping['regla1'] = self.regla1
		mapping['rule1'] = self.rule1
		return mapping

	def getTriggers(self):
		mapping = dict()
		mapping['regla1'] = self.regla1_trigger
		mapping['rule1'] = self.rule1_trigger
		return mapping

	def getHierarchicalTargets(self):
		mapping = dict()
		return mapping


	# Rule regla1
	def regla1(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for a
			symbol_a_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'a'] in equiv[0] and equiv[1] != None:
					symbol_a_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_a_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_a_name in symbol_a_nodes:
			symbol_a = nodes[symbol_a_name]
			n2id['a'] = symbol_a_name
			if symbol_a.sType == 'A':
				# At this point we meet all the conditions.
				stack2        = copy.deepcopy(stack)
				equivalences2 = copy.deepcopy(equivalences)
				r1 = self.regla1_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
				c = copy.deepcopy(r1)
				if 'fina' in locals():
					c.history.append(finishesCombo)
				if len(stack2) > 0: c.stop = True
				ret.append(c)
				if len(stack2) > 0:
					# Set symbol for a...
					for equiv in equivalences2:
						if [me, 'a'] in equiv[0]:
							equiv[1] = symbol_a_name
					newNode = WorldStateHistory(r1)
					global lastNodeId
					lastNodeId += 1
					newNode.nodeId = lastNodeId
					derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
					if 'fina' in locals():
						for n in derivsx: n.history.append(finishesCombo)
						for n in derivsx: n.history.append(fina)
					ret.extend(derivsx)
		return ret
		
		

	# Rule regla1
	def regla1_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_a = snode.graph.nodes[n2id['a']]
			if not (test_symbol_a.sType == 'A'):
				if verbose: print 'test_symbol_a(',n2id['a'],').sType == A' , test_symbol_a.sType == 'A'
				raise WrongRuleExecution('regla1_trigger1')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'b' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['b'] = newName
		newNode.graph.nodes[n2id['b']] = AGMSymbol(n2id['b'], 'B')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['a'], n2id['b'], 'unido')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('regla1@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule rule1
	def rule1(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for a
			symbol_a_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'a'] in equiv[0] and equiv[1] != None:
					symbol_a_nodes = [equiv[1]]
			# Find equivalence for b
			symbol_b_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'b'] in equiv[0] and equiv[1] != None:
					symbol_b_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_a_nodes = symbol_nodes_copy
			symbol_b_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_a_name in symbol_a_nodes:
			symbol_a = nodes[symbol_a_name]
			n2id['a'] = symbol_a_name
			if symbol_a.sType == 'A':
				for symbol_b_name in symbol_b_nodes:
					symbol_b = nodes[symbol_b_name]
					n2id['b'] = symbol_b_name
					if symbol_b.sType == 'B' and symbol_b.name!=symbol_a.name and [n2id["a"],n2id["b"],"unido"] in snode.graph.links:
						# At this point we meet all the conditions.
						stack2        = copy.deepcopy(stack)
						equivalences2 = copy.deepcopy(equivalences)
						r1 = self.rule1_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
						c = copy.deepcopy(r1)
						if 'fina' in locals():
							c.history.append(finishesCombo)
						if len(stack2) > 0: c.stop = True
						ret.append(c)
						if len(stack2) > 0:
							# Set symbol for a...
							for equiv in equivalences2:
								if [me, 'a'] in equiv[0]:
									equiv[1] = symbol_a_name
							# Set symbol for b...
							for equiv in equivalences2:
								if [me, 'b'] in equiv[0]:
									equiv[1] = symbol_b_name
							newNode = WorldStateHistory(r1)
							global lastNodeId
							lastNodeId += 1
							newNode.nodeId = lastNodeId
							derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
							if 'fina' in locals():
								for n in derivsx: n.history.append(finishesCombo)
								for n in derivsx: n.history.append(fina)
							ret.extend(derivsx)
		return ret
		
		

	# Rule rule1
	def rule1_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_a = snode.graph.nodes[n2id['a']]
			if not (test_symbol_a.sType == 'A'):
				if verbose: print 'test_symbol_a(',n2id['a'],').sType == A' , test_symbol_a.sType == 'A'
				raise WrongRuleExecution('rule1_trigger1')
			test_symbol_b = snode.graph.nodes[n2id['b']]
			if not (test_symbol_b.sType == 'B' and test_symbol_b.name!=test_symbol_a.name and [n2id["a"],n2id["b"],"unido"] in snode.graph.links):
				if verbose: print 'test_symbol_b(',n2id['b'],').sType == B' , test_symbol_b.sType == 'B'
				raise WrongRuleExecution('rule1_trigger2')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'c' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['c'] = newName
		newNode.graph.nodes[n2id['c']] = AGMSymbol(n2id['c'], 'C')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['b'], n2id['c'], 'unido')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['c'], n2id['a'], 'unido')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('rule1@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		
