import copy, sys, cPickle
sys.path.append('/usr/local/share/agm/')
from AGGL import *
from agglplanner import *

def computeMaxScore(a, b, maxScore):
	s = 0
	for i in a: s+=i
	for i in b: s+=i
	if s > maxScore: return s
	return maxScore

def getNewIdForSymbol(node):
	m = 1
	for k in node.graph.nodes:
			if int(node.graph.nodes[k].name) >= m:
				m = int(node.graph.nodes[k].name)+1
	return m

lastNodeId = 0

class RuleSet(object):
	def __init__(self):
		object.__init__(self)

# Up to this point, all the code has been generated by the generateAGGLPlanerCode.py file

	def getRules(self):
		mapping = dict()
		mapping['changeRoom'] = self.changeRoom
		mapping['findObjectVisuallyInTable'] = self.findObjectVisuallyInTable
		mapping['findObjectTold'] = self.findObjectTold
		mapping['findGranny'] = self.findGranny
		mapping['recognizeObjMug'] = self.recognizeObjMug
		mapping['recognizeObjGlasses'] = self.recognizeObjGlasses
		mapping['recognizeObjCoffeePot'] = self.recognizeObjCoffeePot
		mapping['recognizeObjFails'] = self.recognizeObjFails
		mapping['setObjectReach'] = self.setObjectReach
		mapping['graspObject'] = self.graspObject
		mapping['handObject'] = self.handObject
		mapping['leaveObject'] = self.leaveObject
		mapping['setObjectSee'] = self.setObjectSee
		mapping['setObjectPosition'] = self.setObjectPosition
		mapping['tellHumanAboutMug'] = self.tellHumanAboutMug
		mapping['tellHumanAboutGlasses'] = self.tellHumanAboutGlasses
		mapping['tellHumanAboutMilk'] = self.tellHumanAboutMilk
		mapping['tellHumanAboutCoffeePot'] = self.tellHumanAboutCoffeePot
		mapping['tellHumanAboutTable'] = self.tellHumanAboutTable
		mapping['tellHumanAboutUnknownObject'] = self.tellHumanAboutUnknownObject
		mapping['makeHumanLook'] = self.makeHumanLook
		mapping['personClassifiesMug'] = self.personClassifiesMug
		mapping['personClassifiesTable'] = self.personClassifiesTable
		mapping['personClassifiesMilkPot'] = self.personClassifiesMilkPot
		mapping['personTellsUsAboutMug'] = self.personTellsUsAboutMug
		mapping['personTellsUsAboutMilkPot'] = self.personTellsUsAboutMilkPot
		mapping['personTellsUsAboutTable'] = self.personTellsUsAboutTable
		mapping['informHumanAboutMovedObject'] = self.informHumanAboutMovedObject
		return mapping

	def getTriggers(self):
		mapping = dict()
		mapping['changeRoom'] = self.changeRoom_trigger
		mapping['findObjectVisuallyInTable'] = self.findObjectVisuallyInTable_trigger
		mapping['findObjectTold'] = self.findObjectTold_trigger
		mapping['findGranny'] = self.findGranny_trigger
		mapping['recognizeObjMug'] = self.recognizeObjMug_trigger
		mapping['recognizeObjGlasses'] = self.recognizeObjGlasses_trigger
		mapping['recognizeObjCoffeePot'] = self.recognizeObjCoffeePot_trigger
		mapping['recognizeObjFails'] = self.recognizeObjFails_trigger
		mapping['setObjectReach'] = self.setObjectReach_trigger
		mapping['graspObject'] = self.graspObject_trigger
		mapping['handObject'] = self.handObject_trigger
		mapping['leaveObject'] = self.leaveObject_trigger
		mapping['setObjectSee'] = self.setObjectSee_trigger
		mapping['setObjectPosition'] = self.setObjectPosition_trigger
		mapping['tellHumanAboutMug'] = self.tellHumanAboutMug_trigger
		mapping['tellHumanAboutGlasses'] = self.tellHumanAboutGlasses_trigger
		mapping['tellHumanAboutMilk'] = self.tellHumanAboutMilk_trigger
		mapping['tellHumanAboutCoffeePot'] = self.tellHumanAboutCoffeePot_trigger
		mapping['tellHumanAboutTable'] = self.tellHumanAboutTable_trigger
		mapping['tellHumanAboutUnknownObject'] = self.tellHumanAboutUnknownObject_trigger
		mapping['makeHumanLook'] = self.makeHumanLook_trigger
		mapping['personClassifiesMug'] = self.personClassifiesMug_trigger
		mapping['personClassifiesTable'] = self.personClassifiesTable_trigger
		mapping['personClassifiesMilkPot'] = self.personClassifiesMilkPot_trigger
		mapping['personTellsUsAboutMug'] = self.personTellsUsAboutMug_trigger
		mapping['personTellsUsAboutMilkPot'] = self.personTellsUsAboutMilkPot_trigger
		mapping['personTellsUsAboutTable'] = self.personTellsUsAboutTable_trigger
		mapping['informHumanAboutMovedObject'] = self.informHumanAboutMovedObject_trigger
		return mapping

	def getHierarchicalTargets(self):
		mapping = dict()
		return mapping


	# Rule changeRoom
	def changeRoom(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for s2
			symbol_s2_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 's2'] in equiv[0] and equiv[1] != None:
					symbol_s2_nodes = [equiv[1]]
			# Find equivalence for s1
			symbol_s1_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 's1'] in equiv[0] and equiv[1] != None:
					symbol_s1_nodes = [equiv[1]]
			# Find equivalence for r1
			symbol_r1_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'r1'] in equiv[0] and equiv[1] != None:
					symbol_r1_nodes = [equiv[1]]
			# Find equivalence for r2
			symbol_r2_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'r2'] in equiv[0] and equiv[1] != None:
					symbol_r2_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_s2_nodes = symbol_nodes_copy
			symbol_s1_nodes = symbol_nodes_copy
			symbol_r1_nodes = symbol_nodes_copy
			symbol_r2_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_r1_name in symbol_r1_nodes:
			symbol_r1 = nodes[symbol_r1_name]
			n2id['r1'] = symbol_r1_name
			if symbol_r1.sType == 'object':
				for symbol_r2_name in symbol_r2_nodes:
					symbol_r2 = nodes[symbol_r2_name]
					n2id['r2'] = symbol_r2_name
					if symbol_r2.sType == 'object' and symbol_r2.name!=symbol_r1.name and [n2id["r1"],n2id["r2"],"transitable"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_r1.name and symbol_robot.name!=symbol_r2.name and [n2id["robot"],n2id["r1"],"in"] in snode.graph.links:
								for symbol_s2_name in symbol_s2_nodes:
									symbol_s2 = nodes[symbol_s2_name]
									n2id['s2'] = symbol_s2_name
									if symbol_s2.sType == 'roomSt' and symbol_s2.name!=symbol_r1.name and symbol_s2.name!=symbol_r2.name and symbol_s2.name!=symbol_robot.name and [n2id["r2"],n2id["s2"],"room"] in snode.graph.links:
										for symbol_s1_name in symbol_s1_nodes:
											symbol_s1 = nodes[symbol_s1_name]
											n2id['s1'] = symbol_s1_name
											if symbol_s1.sType == 'roomSt' and symbol_s1.name!=symbol_r1.name and symbol_s1.name!=symbol_r2.name and symbol_s1.name!=symbol_robot.name and symbol_s1.name!=symbol_s2.name and [n2id["r1"],n2id["s1"],"room"] in snode.graph.links:
												# At this point we meet all the conditions.
												stack2        = copy.deepcopy(stack)
												equivalences2 = copy.deepcopy(equivalences)
												r1 = self.changeRoom_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
												c = copy.deepcopy(r1)
												if 'fina' in locals():
													c.history.append(finishesCombo)
												if len(stack2) > 0: c.stop = True
												ret.append(c)
												if len(stack2) > 0:
													# Set symbol for r1...
													for equiv in equivalences2:
														if [me, 'r1'] in equiv[0]:
															equiv[1] = symbol_r1_name
													# Set symbol for r2...
													for equiv in equivalences2:
														if [me, 'r2'] in equiv[0]:
															equiv[1] = symbol_r2_name
													# Set symbol for robot...
													for equiv in equivalences2:
														if [me, 'robot'] in equiv[0]:
															equiv[1] = symbol_robot_name
													# Set symbol for s2...
													for equiv in equivalences2:
														if [me, 's2'] in equiv[0]:
															equiv[1] = symbol_s2_name
													# Set symbol for s1...
													for equiv in equivalences2:
														if [me, 's1'] in equiv[0]:
															equiv[1] = symbol_s1_name
													newNode = WorldStateHistory(r1)
													global lastNodeId
													lastNodeId += 1
													newNode.nodeId = lastNodeId
													derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
													if 'fina' in locals():
														for n in derivsx: n.history.append(finishesCombo)
														for n in derivsx: n.history.append(fina)
													ret.extend(derivsx)
		return ret
		
		

	# Rule changeRoom
	def changeRoom_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_r1 = snode.graph.nodes[n2id['r1']]
			if not (test_symbol_r1.sType == 'object'):
				if verbose: print 'test_symbol_r1(',n2id['r1'],').sType == object' , test_symbol_r1.sType == 'object'
				raise WrongRuleExecution('changeRoom_trigger1')
			test_symbol_r2 = snode.graph.nodes[n2id['r2']]
			if not (test_symbol_r2.sType == 'object' and test_symbol_r2.name!=test_symbol_r1.name and [n2id["r1"],n2id["r2"],"transitable"] in snode.graph.links):
				if verbose: print 'test_symbol_r2(',n2id['r2'],').sType == object' , test_symbol_r2.sType == 'object'
				raise WrongRuleExecution('changeRoom_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_r1.name and test_symbol_robot.name!=test_symbol_r2.name and [n2id["robot"],n2id["r1"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('changeRoom_trigger3')
			test_symbol_s2 = snode.graph.nodes[n2id['s2']]
			if not (test_symbol_s2.sType == 'roomSt' and test_symbol_s2.name!=test_symbol_r1.name and test_symbol_s2.name!=test_symbol_r2.name and test_symbol_s2.name!=test_symbol_robot.name and [n2id["r2"],n2id["s2"],"room"] in snode.graph.links):
				if verbose: print 'test_symbol_s2(',n2id['s2'],').sType == roomSt' , test_symbol_s2.sType == 'roomSt'
				raise WrongRuleExecution('changeRoom_trigger4')
			test_symbol_s1 = snode.graph.nodes[n2id['s1']]
			if not (test_symbol_s1.sType == 'roomSt' and test_symbol_s1.name!=test_symbol_r1.name and test_symbol_s1.name!=test_symbol_r2.name and test_symbol_s1.name!=test_symbol_robot.name and test_symbol_s1.name!=test_symbol_s2.name and [n2id["r1"],n2id["s1"],"room"] in snode.graph.links):
				if verbose: print 'test_symbol_s1(',n2id['s1'],').sType == roomSt' , test_symbol_s1.sType == 'roomSt'
				raise WrongRuleExecution('changeRoom_trigger5')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['robot'], n2id['r1'], 'in'] ]]
		# Create links
		l = AGMLink(n2id['robot'], n2id['r2'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Textual effects
		nodes = copy.deepcopy(newNode.graph.nodes)
		backVars = n2id.keys()
		for symbol_something_name in nodes:
			symbol_something = nodes[symbol_something_name]
			n2id['something'] = symbol_something_name
			if symbol_something.sType == 'object':  # now the body of the FORALL
				condition2 = [n2id["something"],n2id["robot"],"in"] in snode.graph.links # LINK
				if condition2 == True: # if what's inside the WHEN(if) is True
					if [n2id["something"], n2id["s1"], "in"] in newNode.graph.links:
						newNode.graph.links = [x for x in newNode.graph.links if x.a!=n2id["something"] or x.b!=n2id["s1"] or x.linkType!="in"]
					if not [n2id["something"], n2id["s2"], "in"] in newNode.graph.links:
						newNode.graph.links.append(AGMLink(n2id["something"], n2id["s2"], "in"))
		for k in n2id.keys():
			if not k in backVars:
				del n2id[k]
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('changeRoom@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule findObjectVisuallyInTable
	def findObjectVisuallyInTable(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for contst
			symbol_contst_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'contst'] in equiv[0] and equiv[1] != None:
					symbol_contst_nodes = [equiv[1]]
			# Find equivalence for container
			symbol_container_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'container'] in equiv[0] and equiv[1] != None:
					symbol_container_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for room
			symbol_room_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'room'] in equiv[0] and equiv[1] != None:
					symbol_room_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_contst_nodes = symbol_nodes_copy
			symbol_container_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_room_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_container_name in symbol_container_nodes:
			symbol_container = nodes[symbol_container_name]
			n2id['container'] = symbol_container_name
			if symbol_container.sType == 'object':
				for symbol_robot_name in symbol_robot_nodes:
					symbol_robot = nodes[symbol_robot_name]
					n2id['robot'] = symbol_robot_name
					if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_container.name and [n2id["robot"],n2id["container"],"know"] in snode.graph.links:
						for symbol_contst_name in symbol_contst_nodes:
							symbol_contst = nodes[symbol_contst_name]
							n2id['contst'] = symbol_contst_name
							if symbol_contst.sType == 'objectSt' and symbol_contst.name!=symbol_container.name and symbol_contst.name!=symbol_robot.name and not [n2id["container"],n2id["contst"],"explored"] in snode.graph.links and [n2id["container"],n2id["contst"],"table"] in snode.graph.links and [n2id["container"],n2id["contst"],"reach"] in snode.graph.links:
								for symbol_room_name in symbol_room_nodes:
									symbol_room = nodes[symbol_room_name]
									n2id['room'] = symbol_room_name
									if symbol_room.sType == 'object' and symbol_room.name!=symbol_container.name and symbol_room.name!=symbol_robot.name and symbol_room.name!=symbol_contst.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links and [n2id["container"],n2id["room"],"in"] in snode.graph.links:
										# At this point we meet all the conditions.
										stack2        = copy.deepcopy(stack)
										equivalences2 = copy.deepcopy(equivalences)
										r1 = self.findObjectVisuallyInTable_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
										c = copy.deepcopy(r1)
										if 'fina' in locals():
											c.history.append(finishesCombo)
										if len(stack2) > 0: c.stop = True
										ret.append(c)
										if len(stack2) > 0:
											# Set symbol for container...
											for equiv in equivalences2:
												if [me, 'container'] in equiv[0]:
													equiv[1] = symbol_container_name
											# Set symbol for robot...
											for equiv in equivalences2:
												if [me, 'robot'] in equiv[0]:
													equiv[1] = symbol_robot_name
											# Set symbol for contst...
											for equiv in equivalences2:
												if [me, 'contst'] in equiv[0]:
													equiv[1] = symbol_contst_name
											# Set symbol for room...
											for equiv in equivalences2:
												if [me, 'room'] in equiv[0]:
													equiv[1] = symbol_room_name
											newNode = WorldStateHistory(r1)
											global lastNodeId
											lastNodeId += 1
											newNode.nodeId = lastNodeId
											derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
											if 'fina' in locals():
												for n in derivsx: n.history.append(finishesCombo)
												for n in derivsx: n.history.append(fina)
											ret.extend(derivsx)
		return ret
		
		

	# Rule findObjectVisuallyInTable
	def findObjectVisuallyInTable_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_container = snode.graph.nodes[n2id['container']]
			if not (test_symbol_container.sType == 'object'):
				if verbose: print 'test_symbol_container(',n2id['container'],').sType == object' , test_symbol_container.sType == 'object'
				raise WrongRuleExecution('findObjectVisuallyInTable_trigger1')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_container.name and [n2id["robot"],n2id["container"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('findObjectVisuallyInTable_trigger2')
			test_symbol_contst = snode.graph.nodes[n2id['contst']]
			if not (test_symbol_contst.sType == 'objectSt' and test_symbol_contst.name!=test_symbol_container.name and test_symbol_contst.name!=test_symbol_robot.name and not [n2id["container"],n2id["contst"],"explored"] in snode.graph.links and [n2id["container"],n2id["contst"],"table"] in snode.graph.links and [n2id["container"],n2id["contst"],"reach"] in snode.graph.links):
				if verbose: print 'test_symbol_contst(',n2id['contst'],').sType == objectSt' , test_symbol_contst.sType == 'objectSt'
				raise WrongRuleExecution('findObjectVisuallyInTable_trigger3')
			test_symbol_room = snode.graph.nodes[n2id['room']]
			if not (test_symbol_room.sType == 'object' and test_symbol_room.name!=test_symbol_container.name and test_symbol_room.name!=test_symbol_robot.name and test_symbol_room.name!=test_symbol_contst.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links and [n2id["container"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_room(',n2id['room'],').sType == object' , test_symbol_room.sType == 'object'
				raise WrongRuleExecution('findObjectVisuallyInTable_trigger4')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'status' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['status'] = newName
		newNode.graph.nodes[n2id['status']] = AGMSymbol(n2id['status'], 'objectSt')
		if not 'object' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['object'] = newName
		newNode.graph.nodes[n2id['object']] = AGMSymbol(n2id['object'], 'object')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['robot'], n2id['object'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'unclassified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'noReach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['container'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Textual effects
		nodes = copy.deepcopy(newNode.graph.nodes)
		backVars = n2id.keys()
		for symbol_something_name in nodes:
			symbol_something = nodes[symbol_something_name]
			n2id['something'] = symbol_something_name
			if symbol_something.sType == 'object':  # now the body of the FORALL
				condition2 = [n2id["container"],n2id["something"],"in"] in snode.graph.links # LINK
				if condition2 == True: # if what's inside the WHEN(if) is True
					if not [n2id["object"], n2id["something"], "in"] in newNode.graph.links:
						newNode.graph.links.append(AGMLink(n2id["object"], n2id["something"], "in"))
		for k in n2id.keys():
			if not k in backVars:
				del n2id[k]
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('findObjectVisuallyInTable@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule findObjectTold
	def findObjectTold(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_robot_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_robot_name in symbol_robot_nodes:
			symbol_robot = nodes[symbol_robot_name]
			n2id['robot'] = symbol_robot_name
			if symbol_robot.sType == 'robot':
				# At this point we meet all the conditions.
				stack2        = copy.deepcopy(stack)
				equivalences2 = copy.deepcopy(equivalences)
				r1 = self.findObjectTold_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
				c = copy.deepcopy(r1)
				if 'fina' in locals():
					c.history.append(finishesCombo)
				if len(stack2) > 0: c.stop = True
				ret.append(c)
				if len(stack2) > 0:
					# Set symbol for robot...
					for equiv in equivalences2:
						if [me, 'robot'] in equiv[0]:
							equiv[1] = symbol_robot_name
					newNode = WorldStateHistory(r1)
					global lastNodeId
					lastNodeId += 1
					newNode.nodeId = lastNodeId
					derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
					if 'fina' in locals():
						for n in derivsx: n.history.append(finishesCombo)
						for n in derivsx: n.history.append(fina)
					ret.extend(derivsx)
		return ret
		
		

	# Rule findObjectTold
	def findObjectTold_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot'):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('findObjectTold_trigger1')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'status' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['status'] = newName
		newNode.graph.nodes[n2id['status']] = AGMSymbol(n2id['status'], 'objectSt')
		if not 'object' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['object'] = newName
		newNode.graph.nodes[n2id['object']] = AGMSymbol(n2id['object'], 'object')
		if not 'container' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['container'] = newName
		newNode.graph.nodes[n2id['container']] = AGMSymbol(n2id['container'], 'object')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['robot'], n2id['object'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'noSee')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'unclassified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'noReach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'noPosition')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['container'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Textual effects
		nodes = copy.deepcopy(newNode.graph.nodes)
		backVars = n2id.keys()
		for symbol_something_name in nodes:
			symbol_something = nodes[symbol_something_name]
			n2id['something'] = symbol_something_name
			if symbol_something.sType == 'object':  # now the body of the FORALL
				condition2 = [n2id["container"],n2id["something"],"in"] in snode.graph.links # LINK
				if condition2 == True: # if what's inside the WHEN(if) is True
					if not [n2id["object"], n2id["something"], "in"] in newNode.graph.links:
						newNode.graph.links.append(AGMLink(n2id["object"], n2id["something"], "in"))
		for k in n2id.keys():
			if not k in backVars:
				del n2id[k]
		# Misc stuff
		if not inCombo:
			newNode.cost += 4
			newNode.depth += 1
		newNode.history.append('findObjectTold@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule findGranny
	def findGranny(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for roomSt
			symbol_roomSt_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'roomSt'] in equiv[0] and equiv[1] != None:
					symbol_roomSt_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for personSt
			symbol_personSt_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'personSt'] in equiv[0] and equiv[1] != None:
					symbol_personSt_nodes = [equiv[1]]
			# Find equivalence for room
			symbol_room_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'room'] in equiv[0] and equiv[1] != None:
					symbol_room_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_person_nodes = symbol_nodes_copy
			symbol_roomSt_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_personSt_nodes = symbol_nodes_copy
			symbol_room_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_room_name in symbol_room_nodes:
			symbol_room = nodes[symbol_room_name]
			n2id['room'] = symbol_room_name
			if symbol_room.sType == 'object':
				for symbol_person_name in symbol_person_nodes:
					symbol_person = nodes[symbol_person_name]
					n2id['person'] = symbol_person_name
					if symbol_person.sType == 'person' and symbol_person.name!=symbol_room.name:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_room.name and symbol_robot.name!=symbol_person.name and [n2id["robot"],n2id["person"],"know"] in snode.graph.links and [n2id["robot"],n2id["room"],"in"] in snode.graph.links:
								for symbol_roomSt_name in symbol_roomSt_nodes:
									symbol_roomSt = nodes[symbol_roomSt_name]
									n2id['roomSt'] = symbol_roomSt_name
									if symbol_roomSt.sType == 'roomSt' and symbol_roomSt.name!=symbol_room.name and symbol_roomSt.name!=symbol_person.name and symbol_roomSt.name!=symbol_robot.name and [n2id["room"],n2id["roomSt"],"room"] in snode.graph.links and [n2id["room"],n2id["roomSt"],"noExplored"] in snode.graph.links:
										for symbol_personSt_name in symbol_personSt_nodes:
											symbol_personSt = nodes[symbol_personSt_name]
											n2id['personSt'] = symbol_personSt_name
											if symbol_personSt.sType == 'personSt' and symbol_personSt.name!=symbol_room.name and symbol_personSt.name!=symbol_person.name and symbol_personSt.name!=symbol_robot.name and symbol_personSt.name!=symbol_roomSt.name and [n2id["person"],n2id["personSt"],"granny"] in snode.graph.links and [n2id["person"],n2id["personSt"],"noLocalized"] in snode.graph.links:
												# At this point we meet all the conditions.
												stack2        = copy.deepcopy(stack)
												equivalences2 = copy.deepcopy(equivalences)
												r1 = self.findGranny_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
												c = copy.deepcopy(r1)
												if 'fina' in locals():
													c.history.append(finishesCombo)
												if len(stack2) > 0: c.stop = True
												ret.append(c)
												if len(stack2) > 0:
													# Set symbol for room...
													for equiv in equivalences2:
														if [me, 'room'] in equiv[0]:
															equiv[1] = symbol_room_name
													# Set symbol for person...
													for equiv in equivalences2:
														if [me, 'person'] in equiv[0]:
															equiv[1] = symbol_person_name
													# Set symbol for robot...
													for equiv in equivalences2:
														if [me, 'robot'] in equiv[0]:
															equiv[1] = symbol_robot_name
													# Set symbol for roomSt...
													for equiv in equivalences2:
														if [me, 'roomSt'] in equiv[0]:
															equiv[1] = symbol_roomSt_name
													# Set symbol for personSt...
													for equiv in equivalences2:
														if [me, 'personSt'] in equiv[0]:
															equiv[1] = symbol_personSt_name
													newNode = WorldStateHistory(r1)
													global lastNodeId
													lastNodeId += 1
													newNode.nodeId = lastNodeId
													derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
													if 'fina' in locals():
														for n in derivsx: n.history.append(finishesCombo)
														for n in derivsx: n.history.append(fina)
													ret.extend(derivsx)
		return ret
		
		

	# Rule findGranny
	def findGranny_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_room = snode.graph.nodes[n2id['room']]
			if not (test_symbol_room.sType == 'object'):
				if verbose: print 'test_symbol_room(',n2id['room'],').sType == object' , test_symbol_room.sType == 'object'
				raise WrongRuleExecution('findGranny_trigger1')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_room.name):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('findGranny_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_room.name and test_symbol_robot.name!=test_symbol_person.name and [n2id["robot"],n2id["person"],"know"] in snode.graph.links and [n2id["robot"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('findGranny_trigger3')
			test_symbol_roomSt = snode.graph.nodes[n2id['roomSt']]
			if not (test_symbol_roomSt.sType == 'roomSt' and test_symbol_roomSt.name!=test_symbol_room.name and test_symbol_roomSt.name!=test_symbol_person.name and test_symbol_roomSt.name!=test_symbol_robot.name and [n2id["room"],n2id["roomSt"],"room"] in snode.graph.links and [n2id["room"],n2id["roomSt"],"noExplored"] in snode.graph.links):
				if verbose: print 'test_symbol_roomSt(',n2id['roomSt'],').sType == roomSt' , test_symbol_roomSt.sType == 'roomSt'
				raise WrongRuleExecution('findGranny_trigger4')
			test_symbol_personSt = snode.graph.nodes[n2id['personSt']]
			if not (test_symbol_personSt.sType == 'personSt' and test_symbol_personSt.name!=test_symbol_room.name and test_symbol_personSt.name!=test_symbol_person.name and test_symbol_personSt.name!=test_symbol_robot.name and test_symbol_personSt.name!=test_symbol_roomSt.name and [n2id["person"],n2id["personSt"],"granny"] in snode.graph.links and [n2id["person"],n2id["personSt"],"noLocalized"] in snode.graph.links):
				if verbose: print 'test_symbol_personSt(',n2id['personSt'],').sType == personSt' , test_symbol_personSt.sType == 'personSt'
				raise WrongRuleExecution('findGranny_trigger5')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['person'], n2id['personSt'], 'noLocalized'] ]]
		# Create links
		l = AGMLink(n2id['person'], n2id['room'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['person'], n2id['personSt'], 'localized')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Textual effects
		nodes = copy.deepcopy(newNode.graph.nodes)
		backVars = n2id.keys()
		for symbol_aRoom_name in nodes:
			symbol_aRoom = nodes[symbol_aRoom_name]
			n2id['aRoom'] = symbol_aRoom_name
			if symbol_aRoom.sType == 'object':  # now the body of the FORALL
				for symbol_aRoomSt_name in nodes:
					symbol_aRoomSt = nodes[symbol_aRoomSt_name]
					n2id['aRoomSt'] = symbol_aRoomSt_name
					if symbol_aRoomSt.sType == 'roomSt':  # now the body of the FORALL
						if [n2id["aRoom"], n2id["aRoomSt"], "explored"] in newNode.graph.links:
							newNode.graph.links = [x for x in newNode.graph.links if x.a!=n2id["aRoom"] or x.b!=n2id["aRoomSt"] or x.linkType!="explored"]
						if not [n2id["aRoom"], n2id["aRoomSt"], "noExplored"] in newNode.graph.links:
							newNode.graph.links.append(AGMLink(n2id["aRoom"], n2id["aRoomSt"], "noExplored"))
		for k in n2id.keys():
			if not k in backVars:
				del n2id[k]
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('findGranny@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule recognizeObjMug
	def recognizeObjMug(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for status
			symbol_status_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'status'] in equiv[0] and equiv[1] != None:
					symbol_status_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_status_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_status_name in symbol_status_nodes:
					symbol_status = nodes[symbol_status_name]
					n2id['status'] = symbol_status_name
					if symbol_status.sType == 'objectSt' and symbol_status.name!=symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_object.name and symbol_robot.name!=symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links:
								# At this point we meet all the conditions.
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.recognizeObjMug_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for object...
									for equiv in equivalences2:
										if [me, 'object'] in equiv[0]:
											equiv[1] = symbol_object_name
									# Set symbol for status...
									for equiv in equivalences2:
										if [me, 'status'] in equiv[0]:
											equiv[1] = symbol_status_name
									# Set symbol for robot...
									for equiv in equivalences2:
										if [me, 'robot'] in equiv[0]:
											equiv[1] = symbol_robot_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule recognizeObjMug
	def recognizeObjMug_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('recognizeObjMug_trigger1')
			test_symbol_status = snode.graph.nodes[n2id['status']]
			if not (test_symbol_status.sType == 'objectSt' and test_symbol_status.name!=test_symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links):
				if verbose: print 'test_symbol_status(',n2id['status'],').sType == objectSt' , test_symbol_status.sType == 'objectSt'
				raise WrongRuleExecution('recognizeObjMug_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_object.name and test_symbol_robot.name!=test_symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('recognizeObjMug_trigger3')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['status'], 'unclassified'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['status'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'mug')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('recognizeObjMug@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule recognizeObjGlasses
	def recognizeObjGlasses(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for status
			symbol_status_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'status'] in equiv[0] and equiv[1] != None:
					symbol_status_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_status_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_status_name in symbol_status_nodes:
					symbol_status = nodes[symbol_status_name]
					n2id['status'] = symbol_status_name
					if symbol_status.sType == 'objectSt' and symbol_status.name!=symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_object.name and symbol_robot.name!=symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links:
								# At this point we meet all the conditions.
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.recognizeObjGlasses_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for object...
									for equiv in equivalences2:
										if [me, 'object'] in equiv[0]:
											equiv[1] = symbol_object_name
									# Set symbol for status...
									for equiv in equivalences2:
										if [me, 'status'] in equiv[0]:
											equiv[1] = symbol_status_name
									# Set symbol for robot...
									for equiv in equivalences2:
										if [me, 'robot'] in equiv[0]:
											equiv[1] = symbol_robot_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule recognizeObjGlasses
	def recognizeObjGlasses_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('recognizeObjGlasses_trigger1')
			test_symbol_status = snode.graph.nodes[n2id['status']]
			if not (test_symbol_status.sType == 'objectSt' and test_symbol_status.name!=test_symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links):
				if verbose: print 'test_symbol_status(',n2id['status'],').sType == objectSt' , test_symbol_status.sType == 'objectSt'
				raise WrongRuleExecution('recognizeObjGlasses_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_object.name and test_symbol_robot.name!=test_symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('recognizeObjGlasses_trigger3')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['status'], 'unclassified'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['status'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'glasses')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('recognizeObjGlasses@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule recognizeObjCoffeePot
	def recognizeObjCoffeePot(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for status
			symbol_status_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'status'] in equiv[0] and equiv[1] != None:
					symbol_status_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_status_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_status_name in symbol_status_nodes:
					symbol_status = nodes[symbol_status_name]
					n2id['status'] = symbol_status_name
					if symbol_status.sType == 'objectSt' and symbol_status.name!=symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_object.name and symbol_robot.name!=symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links:
								# At this point we meet all the conditions.
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.recognizeObjCoffeePot_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for object...
									for equiv in equivalences2:
										if [me, 'object'] in equiv[0]:
											equiv[1] = symbol_object_name
									# Set symbol for status...
									for equiv in equivalences2:
										if [me, 'status'] in equiv[0]:
											equiv[1] = symbol_status_name
									# Set symbol for robot...
									for equiv in equivalences2:
										if [me, 'robot'] in equiv[0]:
											equiv[1] = symbol_robot_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule recognizeObjCoffeePot
	def recognizeObjCoffeePot_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('recognizeObjCoffeePot_trigger1')
			test_symbol_status = snode.graph.nodes[n2id['status']]
			if not (test_symbol_status.sType == 'objectSt' and test_symbol_status.name!=test_symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links):
				if verbose: print 'test_symbol_status(',n2id['status'],').sType == objectSt' , test_symbol_status.sType == 'objectSt'
				raise WrongRuleExecution('recognizeObjCoffeePot_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_object.name and test_symbol_robot.name!=test_symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('recognizeObjCoffeePot_trigger3')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['status'], 'unclassified'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['status'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['object'], n2id['status'], 'coffeepot')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('recognizeObjCoffeePot@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule recognizeObjFails
	def recognizeObjFails(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for status
			symbol_status_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'status'] in equiv[0] and equiv[1] != None:
					symbol_status_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_status_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_status_name in symbol_status_nodes:
					symbol_status = nodes[symbol_status_name]
					n2id['status'] = symbol_status_name
					if symbol_status.sType == 'objectSt' and symbol_status.name!=symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_object.name and symbol_robot.name!=symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links:
								# At this point we meet all the conditions.
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.recognizeObjFails_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for object...
									for equiv in equivalences2:
										if [me, 'object'] in equiv[0]:
											equiv[1] = symbol_object_name
									# Set symbol for status...
									for equiv in equivalences2:
										if [me, 'status'] in equiv[0]:
											equiv[1] = symbol_status_name
									# Set symbol for robot...
									for equiv in equivalences2:
										if [me, 'robot'] in equiv[0]:
											equiv[1] = symbol_robot_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule recognizeObjFails
	def recognizeObjFails_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('recognizeObjFails_trigger1')
			test_symbol_status = snode.graph.nodes[n2id['status']]
			if not (test_symbol_status.sType == 'objectSt' and test_symbol_status.name!=test_symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"see"] in snode.graph.links and [n2id["object"],n2id["status"],"position"] in snode.graph.links and [n2id["object"],n2id["status"],"unclassified"] in snode.graph.links):
				if verbose: print 'test_symbol_status(',n2id['status'],').sType == objectSt' , test_symbol_status.sType == 'objectSt'
				raise WrongRuleExecution('recognizeObjFails_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_object.name and test_symbol_robot.name!=test_symbol_status.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('recognizeObjFails_trigger3')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['status'], 'unclassified'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['status'], 'classifailed')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('recognizeObjFails@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule setObjectReach
	def setObjectReach(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for status
			symbol_status_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'status'] in equiv[0] and equiv[1] != None:
					symbol_status_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for room
			symbol_room_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'room'] in equiv[0] and equiv[1] != None:
					symbol_room_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_status_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_room_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_status_name in symbol_status_nodes:
					symbol_status = nodes[symbol_status_name]
					n2id['status'] = symbol_status_name
					if symbol_status.sType == 'objectSt' and symbol_status.name!=symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"noReach"] in snode.graph.links and [n2id["object"],n2id["status"],"reachable"] in snode.graph.links:
						for symbol_room_name in symbol_room_nodes:
							symbol_room = nodes[symbol_room_name]
							n2id['room'] = symbol_room_name
							if symbol_room.sType == 'object' and symbol_room.name!=symbol_object.name and symbol_room.name!=symbol_status.name and [n2id["object"],n2id["room"],"in"] in snode.graph.links:
								for symbol_robot_name in symbol_robot_nodes:
									symbol_robot = nodes[symbol_robot_name]
									n2id['robot'] = symbol_robot_name
									if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_object.name and symbol_robot.name!=symbol_status.name and symbol_robot.name!=symbol_room.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links:
										# At this point we meet all the conditions.
										stack2        = copy.deepcopy(stack)
										equivalences2 = copy.deepcopy(equivalences)
										r1 = self.setObjectReach_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
										c = copy.deepcopy(r1)
										if 'fina' in locals():
											c.history.append(finishesCombo)
										if len(stack2) > 0: c.stop = True
										ret.append(c)
										if len(stack2) > 0:
											# Set symbol for object...
											for equiv in equivalences2:
												if [me, 'object'] in equiv[0]:
													equiv[1] = symbol_object_name
											# Set symbol for status...
											for equiv in equivalences2:
												if [me, 'status'] in equiv[0]:
													equiv[1] = symbol_status_name
											# Set symbol for room...
											for equiv in equivalences2:
												if [me, 'room'] in equiv[0]:
													equiv[1] = symbol_room_name
											# Set symbol for robot...
											for equiv in equivalences2:
												if [me, 'robot'] in equiv[0]:
													equiv[1] = symbol_robot_name
											newNode = WorldStateHistory(r1)
											global lastNodeId
											lastNodeId += 1
											newNode.nodeId = lastNodeId
											derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
											if 'fina' in locals():
												for n in derivsx: n.history.append(finishesCombo)
												for n in derivsx: n.history.append(fina)
											ret.extend(derivsx)
		return ret
		
		

	# Rule setObjectReach
	def setObjectReach_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('setObjectReach_trigger1')
			test_symbol_status = snode.graph.nodes[n2id['status']]
			if not (test_symbol_status.sType == 'objectSt' and test_symbol_status.name!=test_symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"noReach"] in snode.graph.links and [n2id["object"],n2id["status"],"reachable"] in snode.graph.links):
				if verbose: print 'test_symbol_status(',n2id['status'],').sType == objectSt' , test_symbol_status.sType == 'objectSt'
				raise WrongRuleExecution('setObjectReach_trigger2')
			test_symbol_room = snode.graph.nodes[n2id['room']]
			if not (test_symbol_room.sType == 'object' and test_symbol_room.name!=test_symbol_object.name and test_symbol_room.name!=test_symbol_status.name and [n2id["object"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_room(',n2id['room'],').sType == object' , test_symbol_room.sType == 'object'
				raise WrongRuleExecution('setObjectReach_trigger3')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_object.name and test_symbol_robot.name!=test_symbol_status.name and test_symbol_robot.name!=test_symbol_room.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('setObjectReach_trigger4')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['status'], 'noReach'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['status'], 'reach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('setObjectReach@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule graspObject
	def graspObject(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for table
			symbol_table_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'table'] in equiv[0] and equiv[1] != None:
					symbol_table_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for ost
			symbol_ost_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'ost'] in equiv[0] and equiv[1] != None:
					symbol_ost_nodes = [equiv[1]]
			# Find equivalence for room
			symbol_room_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'room'] in equiv[0] and equiv[1] != None:
					symbol_room_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_table_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_ost_nodes = symbol_nodes_copy
			symbol_room_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_robot_name in symbol_robot_nodes:
					symbol_robot = nodes[symbol_robot_name]
					n2id['robot'] = symbol_robot_name
					if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_object.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links:
						for symbol_table_name in symbol_table_nodes:
							symbol_table = nodes[symbol_table_name]
							n2id['table'] = symbol_table_name
							if symbol_table.sType == 'object' and symbol_table.name!=symbol_object.name and symbol_table.name!=symbol_robot.name and [n2id["object"],n2id["table"],"in"] in snode.graph.links:
								for symbol_room_name in symbol_room_nodes:
									symbol_room = nodes[symbol_room_name]
									n2id['room'] = symbol_room_name
									if symbol_room.sType == 'object' and symbol_room.name!=symbol_object.name and symbol_room.name!=symbol_robot.name and symbol_room.name!=symbol_table.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links and [n2id["table"],n2id["room"],"in"] in snode.graph.links:
										for symbol_ost_name in symbol_ost_nodes:
											symbol_ost = nodes[symbol_ost_name]
											n2id['ost'] = symbol_ost_name
											if symbol_ost.sType == 'objectSt' and symbol_ost.name!=symbol_object.name and symbol_ost.name!=symbol_robot.name and symbol_ost.name!=symbol_table.name and symbol_ost.name!=symbol_room.name and [n2id["object"],n2id["ost"],"reach"] in snode.graph.links:
												# At this point we meet all the conditions.
												stack2        = copy.deepcopy(stack)
												equivalences2 = copy.deepcopy(equivalences)
												r1 = self.graspObject_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
												c = copy.deepcopy(r1)
												if 'fina' in locals():
													c.history.append(finishesCombo)
												if len(stack2) > 0: c.stop = True
												ret.append(c)
												if len(stack2) > 0:
													# Set symbol for object...
													for equiv in equivalences2:
														if [me, 'object'] in equiv[0]:
															equiv[1] = symbol_object_name
													# Set symbol for robot...
													for equiv in equivalences2:
														if [me, 'robot'] in equiv[0]:
															equiv[1] = symbol_robot_name
													# Set symbol for table...
													for equiv in equivalences2:
														if [me, 'table'] in equiv[0]:
															equiv[1] = symbol_table_name
													# Set symbol for room...
													for equiv in equivalences2:
														if [me, 'room'] in equiv[0]:
															equiv[1] = symbol_room_name
													# Set symbol for ost...
													for equiv in equivalences2:
														if [me, 'ost'] in equiv[0]:
															equiv[1] = symbol_ost_name
													newNode = WorldStateHistory(r1)
													global lastNodeId
													lastNodeId += 1
													newNode.nodeId = lastNodeId
													derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
													if 'fina' in locals():
														for n in derivsx: n.history.append(finishesCombo)
														for n in derivsx: n.history.append(fina)
													ret.extend(derivsx)
		return ret
		
		

	# Rule graspObject
	def graspObject_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('graspObject_trigger1')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_object.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('graspObject_trigger2')
			test_symbol_table = snode.graph.nodes[n2id['table']]
			if not (test_symbol_table.sType == 'object' and test_symbol_table.name!=test_symbol_object.name and test_symbol_table.name!=test_symbol_robot.name and [n2id["object"],n2id["table"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_table(',n2id['table'],').sType == object' , test_symbol_table.sType == 'object'
				raise WrongRuleExecution('graspObject_trigger3')
			test_symbol_room = snode.graph.nodes[n2id['room']]
			if not (test_symbol_room.sType == 'object' and test_symbol_room.name!=test_symbol_object.name and test_symbol_room.name!=test_symbol_robot.name and test_symbol_room.name!=test_symbol_table.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links and [n2id["table"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_room(',n2id['room'],').sType == object' , test_symbol_room.sType == 'object'
				raise WrongRuleExecution('graspObject_trigger4')
			test_symbol_ost = snode.graph.nodes[n2id['ost']]
			if not (test_symbol_ost.sType == 'objectSt' and test_symbol_ost.name!=test_symbol_object.name and test_symbol_ost.name!=test_symbol_robot.name and test_symbol_ost.name!=test_symbol_table.name and test_symbol_ost.name!=test_symbol_room.name and [n2id["object"],n2id["ost"],"reach"] in snode.graph.links):
				if verbose: print 'test_symbol_ost(',n2id['ost'],').sType == objectSt' , test_symbol_ost.sType == 'objectSt'
				raise WrongRuleExecution('graspObject_trigger5')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['table'], 'in'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['robot'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('graspObject@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule handObject
	def handObject(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for room
			symbol_room_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'room'] in equiv[0] and equiv[1] != None:
					symbol_room_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_person_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_room_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_robot_name in symbol_robot_nodes:
			symbol_robot = nodes[symbol_robot_name]
			n2id['robot'] = symbol_robot_name
			if symbol_robot.sType == 'robot':
				for symbol_object_name in symbol_object_nodes:
					symbol_object = nodes[symbol_object_name]
					n2id['object'] = symbol_object_name
					if symbol_object.sType == 'object' and symbol_object.name!=symbol_robot.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links and [n2id["object"],n2id["robot"],"in"] in snode.graph.links:
						for symbol_room_name in symbol_room_nodes:
							symbol_room = nodes[symbol_room_name]
							n2id['room'] = symbol_room_name
							if symbol_room.sType == 'object' and symbol_room.name!=symbol_robot.name and symbol_room.name!=symbol_object.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links:
								for symbol_person_name in symbol_person_nodes:
									symbol_person = nodes[symbol_person_name]
									n2id['person'] = symbol_person_name
									if symbol_person.sType == 'person' and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_object.name and symbol_person.name!=symbol_room.name and [n2id["person"],n2id["room"],"in"] in snode.graph.links:
										# At this point we meet all the conditions.
										stack2        = copy.deepcopy(stack)
										equivalences2 = copy.deepcopy(equivalences)
										r1 = self.handObject_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
										c = copy.deepcopy(r1)
										if 'fina' in locals():
											c.history.append(finishesCombo)
										if len(stack2) > 0: c.stop = True
										ret.append(c)
										if len(stack2) > 0:
											# Set symbol for robot...
											for equiv in equivalences2:
												if [me, 'robot'] in equiv[0]:
													equiv[1] = symbol_robot_name
											# Set symbol for object...
											for equiv in equivalences2:
												if [me, 'object'] in equiv[0]:
													equiv[1] = symbol_object_name
											# Set symbol for room...
											for equiv in equivalences2:
												if [me, 'room'] in equiv[0]:
													equiv[1] = symbol_room_name
											# Set symbol for person...
											for equiv in equivalences2:
												if [me, 'person'] in equiv[0]:
													equiv[1] = symbol_person_name
											newNode = WorldStateHistory(r1)
											global lastNodeId
											lastNodeId += 1
											newNode.nodeId = lastNodeId
											derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
											if 'fina' in locals():
												for n in derivsx: n.history.append(finishesCombo)
												for n in derivsx: n.history.append(fina)
											ret.extend(derivsx)
		return ret
		
		

	# Rule handObject
	def handObject_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot'):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('handObject_trigger1')
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object' and test_symbol_object.name!=test_symbol_robot.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links and [n2id["object"],n2id["robot"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('handObject_trigger2')
			test_symbol_room = snode.graph.nodes[n2id['room']]
			if not (test_symbol_room.sType == 'object' and test_symbol_room.name!=test_symbol_robot.name and test_symbol_room.name!=test_symbol_object.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_room(',n2id['room'],').sType == object' , test_symbol_room.sType == 'object'
				raise WrongRuleExecution('handObject_trigger3')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_object.name and test_symbol_person.name!=test_symbol_room.name and [n2id["person"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('handObject_trigger4')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['robot'], 'in'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['person'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('handObject@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule leaveObject
	def leaveObject(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for table
			symbol_table_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'table'] in equiv[0] and equiv[1] != None:
					symbol_table_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for room
			symbol_room_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'room'] in equiv[0] and equiv[1] != None:
					symbol_room_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_table_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_room_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_robot_name in symbol_robot_nodes:
			symbol_robot = nodes[symbol_robot_name]
			n2id['robot'] = symbol_robot_name
			if symbol_robot.sType == 'robot':
				for symbol_object_name in symbol_object_nodes:
					symbol_object = nodes[symbol_object_name]
					n2id['object'] = symbol_object_name
					if symbol_object.sType == 'object' and symbol_object.name!=symbol_robot.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links and [n2id["object"],n2id["robot"],"in"] in snode.graph.links:
						for symbol_table_name in symbol_table_nodes:
							symbol_table = nodes[symbol_table_name]
							n2id['table'] = symbol_table_name
							if symbol_table.sType == 'object' and symbol_table.name!=symbol_robot.name and symbol_table.name!=symbol_object.name:
								for symbol_room_name in symbol_room_nodes:
									symbol_room = nodes[symbol_room_name]
									n2id['room'] = symbol_room_name
									if symbol_room.sType == 'object' and symbol_room.name!=symbol_robot.name and symbol_room.name!=symbol_object.name and symbol_room.name!=symbol_table.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links and [n2id["table"],n2id["room"],"in"] in snode.graph.links:
										# At this point we meet all the conditions.
										stack2        = copy.deepcopy(stack)
										equivalences2 = copy.deepcopy(equivalences)
										r1 = self.leaveObject_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
										c = copy.deepcopy(r1)
										if 'fina' in locals():
											c.history.append(finishesCombo)
										if len(stack2) > 0: c.stop = True
										ret.append(c)
										if len(stack2) > 0:
											# Set symbol for robot...
											for equiv in equivalences2:
												if [me, 'robot'] in equiv[0]:
													equiv[1] = symbol_robot_name
											# Set symbol for object...
											for equiv in equivalences2:
												if [me, 'object'] in equiv[0]:
													equiv[1] = symbol_object_name
											# Set symbol for table...
											for equiv in equivalences2:
												if [me, 'table'] in equiv[0]:
													equiv[1] = symbol_table_name
											# Set symbol for room...
											for equiv in equivalences2:
												if [me, 'room'] in equiv[0]:
													equiv[1] = symbol_room_name
											newNode = WorldStateHistory(r1)
											global lastNodeId
											lastNodeId += 1
											newNode.nodeId = lastNodeId
											derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
											if 'fina' in locals():
												for n in derivsx: n.history.append(finishesCombo)
												for n in derivsx: n.history.append(fina)
											ret.extend(derivsx)
		return ret
		
		

	# Rule leaveObject
	def leaveObject_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot'):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('leaveObject_trigger1')
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object' and test_symbol_object.name!=test_symbol_robot.name and [n2id["robot"],n2id["object"],"know"] in snode.graph.links and [n2id["object"],n2id["robot"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('leaveObject_trigger2')
			test_symbol_table = snode.graph.nodes[n2id['table']]
			if not (test_symbol_table.sType == 'object' and test_symbol_table.name!=test_symbol_robot.name and test_symbol_table.name!=test_symbol_object.name):
				if verbose: print 'test_symbol_table(',n2id['table'],').sType == object' , test_symbol_table.sType == 'object'
				raise WrongRuleExecution('leaveObject_trigger3')
			test_symbol_room = snode.graph.nodes[n2id['room']]
			if not (test_symbol_room.sType == 'object' and test_symbol_room.name!=test_symbol_robot.name and test_symbol_room.name!=test_symbol_object.name and test_symbol_room.name!=test_symbol_table.name and [n2id["robot"],n2id["room"],"in"] in snode.graph.links and [n2id["table"],n2id["room"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_room(',n2id['room'],').sType == object' , test_symbol_room.sType == 'object'
				raise WrongRuleExecution('leaveObject_trigger4')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['robot'], 'in'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['table'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('leaveObject@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule setObjectSee
	def setObjectSee(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for status
			symbol_status_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'status'] in equiv[0] and equiv[1] != None:
					symbol_status_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_status_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_status_name in symbol_status_nodes:
					symbol_status = nodes[symbol_status_name]
					n2id['status'] = symbol_status_name
					if symbol_status.sType == 'objectSt' and symbol_status.name!=symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"noSee"] in snode.graph.links:
						# At this point we meet all the conditions.
						stack2        = copy.deepcopy(stack)
						equivalences2 = copy.deepcopy(equivalences)
						r1 = self.setObjectSee_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
						c = copy.deepcopy(r1)
						if 'fina' in locals():
							c.history.append(finishesCombo)
						if len(stack2) > 0: c.stop = True
						ret.append(c)
						if len(stack2) > 0:
							# Set symbol for object...
							for equiv in equivalences2:
								if [me, 'object'] in equiv[0]:
									equiv[1] = symbol_object_name
							# Set symbol for status...
							for equiv in equivalences2:
								if [me, 'status'] in equiv[0]:
									equiv[1] = symbol_status_name
							newNode = WorldStateHistory(r1)
							global lastNodeId
							lastNodeId += 1
							newNode.nodeId = lastNodeId
							derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
							if 'fina' in locals():
								for n in derivsx: n.history.append(finishesCombo)
								for n in derivsx: n.history.append(fina)
							ret.extend(derivsx)
		return ret
		
		

	# Rule setObjectSee
	def setObjectSee_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('setObjectSee_trigger1')
			test_symbol_status = snode.graph.nodes[n2id['status']]
			if not (test_symbol_status.sType == 'objectSt' and test_symbol_status.name!=test_symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"noSee"] in snode.graph.links):
				if verbose: print 'test_symbol_status(',n2id['status'],').sType == objectSt' , test_symbol_status.sType == 'objectSt'
				raise WrongRuleExecution('setObjectSee_trigger2')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['status'], 'noSee'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['status'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('setObjectSee@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule setObjectPosition
	def setObjectPosition(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for status
			symbol_status_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'status'] in equiv[0] and equiv[1] != None:
					symbol_status_nodes = [equiv[1]]
			# Find equivalence for object
			symbol_object_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'object'] in equiv[0] and equiv[1] != None:
					symbol_object_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_status_nodes = symbol_nodes_copy
			symbol_object_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_object_name in symbol_object_nodes:
			symbol_object = nodes[symbol_object_name]
			n2id['object'] = symbol_object_name
			if symbol_object.sType == 'object':
				for symbol_status_name in symbol_status_nodes:
					symbol_status = nodes[symbol_status_name]
					n2id['status'] = symbol_status_name
					if symbol_status.sType == 'objectSt' and symbol_status.name!=symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"noPosition"] in snode.graph.links:
						# At this point we meet all the conditions.
						stack2        = copy.deepcopy(stack)
						equivalences2 = copy.deepcopy(equivalences)
						r1 = self.setObjectPosition_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
						c = copy.deepcopy(r1)
						if 'fina' in locals():
							c.history.append(finishesCombo)
						if len(stack2) > 0: c.stop = True
						ret.append(c)
						if len(stack2) > 0:
							# Set symbol for object...
							for equiv in equivalences2:
								if [me, 'object'] in equiv[0]:
									equiv[1] = symbol_object_name
							# Set symbol for status...
							for equiv in equivalences2:
								if [me, 'status'] in equiv[0]:
									equiv[1] = symbol_status_name
							newNode = WorldStateHistory(r1)
							global lastNodeId
							lastNodeId += 1
							newNode.nodeId = lastNodeId
							derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
							if 'fina' in locals():
								for n in derivsx: n.history.append(finishesCombo)
								for n in derivsx: n.history.append(fina)
							ret.extend(derivsx)
		return ret
		
		

	# Rule setObjectPosition
	def setObjectPosition_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_object = snode.graph.nodes[n2id['object']]
			if not (test_symbol_object.sType == 'object'):
				if verbose: print 'test_symbol_object(',n2id['object'],').sType == object' , test_symbol_object.sType == 'object'
				raise WrongRuleExecution('setObjectPosition_trigger1')
			test_symbol_status = snode.graph.nodes[n2id['status']]
			if not (test_symbol_status.sType == 'objectSt' and test_symbol_status.name!=test_symbol_object.name and [n2id["object"],n2id["status"],"hasStatus"] in snode.graph.links and [n2id["object"],n2id["status"],"noPosition"] in snode.graph.links):
				if verbose: print 'test_symbol_status(',n2id['status'],').sType == objectSt' , test_symbol_status.sType == 'objectSt'
				raise WrongRuleExecution('setObjectPosition_trigger2')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['object'], n2id['status'], 'noPosition'] ]]
		# Create links
		l = AGMLink(n2id['object'], n2id['status'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('setObjectPosition@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule tellHumanAboutMug
	def tellHumanAboutMug(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for conth
			symbol_conth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'conth'] in equiv[0] and equiv[1] != None:
					symbol_conth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for contr
			symbol_contr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'contr'] in equiv[0] and equiv[1] != None:
					symbol_contr_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_conth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_contr_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_statusr_name in symbol_statusr_nodes:
					symbol_statusr = nodes[symbol_statusr_name]
					n2id['statusr'] = symbol_statusr_name
					if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"mug"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and symbol_robot.name!=symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_contr_name in symbol_contr_nodes:
									symbol_contr = nodes[symbol_contr_name]
									n2id['contr'] = symbol_contr_name
									if symbol_contr.sType == 'object' and symbol_contr.name!=symbol_objectr.name and symbol_contr.name!=symbol_statusr.name and symbol_contr.name!=symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_statusr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links:
												for symbol_conth_name in symbol_conth_nodes:
													symbol_conth = nodes[symbol_conth_name]
													n2id['conth'] = symbol_conth_name
													if symbol_conth.sType == 'object' and symbol_conth.name!=symbol_objectr.name and symbol_conth.name!=symbol_statusr.name and symbol_conth.name!=symbol_robot.name and symbol_conth.name!=symbol_contr.name and symbol_conth.name!=symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.tellHumanAboutMug_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for contr...
															for equiv in equivalences2:
																if [me, 'contr'] in equiv[0]:
																	equiv[1] = symbol_contr_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for conth...
															for equiv in equivalences2:
																if [me, 'conth'] in equiv[0]:
																	equiv[1] = symbol_conth_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule tellHumanAboutMug
	def tellHumanAboutMug_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutMug_trigger1')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"mug"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('tellHumanAboutMug_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and test_symbol_robot.name!=test_symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('tellHumanAboutMug_trigger3')
			test_symbol_contr = snode.graph.nodes[n2id['contr']]
			if not (test_symbol_contr.sType == 'object' and test_symbol_contr.name!=test_symbol_objectr.name and test_symbol_contr.name!=test_symbol_statusr.name and test_symbol_contr.name!=test_symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_contr(',n2id['contr'],').sType == object' , test_symbol_contr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutMug_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_statusr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('tellHumanAboutMug_trigger5')
			test_symbol_conth = snode.graph.nodes[n2id['conth']]
			if not (test_symbol_conth.sType == 'object' and test_symbol_conth.name!=test_symbol_objectr.name and test_symbol_conth.name!=test_symbol_statusr.name and test_symbol_conth.name!=test_symbol_robot.name and test_symbol_conth.name!=test_symbol_contr.name and test_symbol_conth.name!=test_symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_conth(',n2id['conth'],').sType == object' , test_symbol_conth.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutMug_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'objecth' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['objecth'] = newName
		newNode.graph.nodes[n2id['objecth']] = AGMSymbol(n2id['objecth'], 'object')
		if not 'statush' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['statush'] = newName
		newNode.graph.nodes[n2id['statush']] = AGMSymbol(n2id['statush'], 'objectSt')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['person'], n2id['objecth'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['objecth'], 'eq')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['conth'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'mug')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('tellHumanAboutMug@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule tellHumanAboutGlasses
	def tellHumanAboutGlasses(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for conth
			symbol_conth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'conth'] in equiv[0] and equiv[1] != None:
					symbol_conth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for contr
			symbol_contr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'contr'] in equiv[0] and equiv[1] != None:
					symbol_contr_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_conth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_contr_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_statusr_name in symbol_statusr_nodes:
					symbol_statusr = nodes[symbol_statusr_name]
					n2id['statusr'] = symbol_statusr_name
					if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"glasses"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and symbol_robot.name!=symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_contr_name in symbol_contr_nodes:
									symbol_contr = nodes[symbol_contr_name]
									n2id['contr'] = symbol_contr_name
									if symbol_contr.sType == 'object' and symbol_contr.name!=symbol_objectr.name and symbol_contr.name!=symbol_statusr.name and symbol_contr.name!=symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_statusr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links:
												for symbol_conth_name in symbol_conth_nodes:
													symbol_conth = nodes[symbol_conth_name]
													n2id['conth'] = symbol_conth_name
													if symbol_conth.sType == 'object' and symbol_conth.name!=symbol_objectr.name and symbol_conth.name!=symbol_statusr.name and symbol_conth.name!=symbol_robot.name and symbol_conth.name!=symbol_contr.name and symbol_conth.name!=symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.tellHumanAboutGlasses_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for contr...
															for equiv in equivalences2:
																if [me, 'contr'] in equiv[0]:
																	equiv[1] = symbol_contr_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for conth...
															for equiv in equivalences2:
																if [me, 'conth'] in equiv[0]:
																	equiv[1] = symbol_conth_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule tellHumanAboutGlasses
	def tellHumanAboutGlasses_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutGlasses_trigger1')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"glasses"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('tellHumanAboutGlasses_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and test_symbol_robot.name!=test_symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('tellHumanAboutGlasses_trigger3')
			test_symbol_contr = snode.graph.nodes[n2id['contr']]
			if not (test_symbol_contr.sType == 'object' and test_symbol_contr.name!=test_symbol_objectr.name and test_symbol_contr.name!=test_symbol_statusr.name and test_symbol_contr.name!=test_symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_contr(',n2id['contr'],').sType == object' , test_symbol_contr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutGlasses_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_statusr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('tellHumanAboutGlasses_trigger5')
			test_symbol_conth = snode.graph.nodes[n2id['conth']]
			if not (test_symbol_conth.sType == 'object' and test_symbol_conth.name!=test_symbol_objectr.name and test_symbol_conth.name!=test_symbol_statusr.name and test_symbol_conth.name!=test_symbol_robot.name and test_symbol_conth.name!=test_symbol_contr.name and test_symbol_conth.name!=test_symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_conth(',n2id['conth'],').sType == object' , test_symbol_conth.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutGlasses_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'objecth' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['objecth'] = newName
		newNode.graph.nodes[n2id['objecth']] = AGMSymbol(n2id['objecth'], 'object')
		if not 'statush' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['statush'] = newName
		newNode.graph.nodes[n2id['statush']] = AGMSymbol(n2id['statush'], 'objectSt')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['person'], n2id['objecth'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['objecth'], 'eq')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['conth'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'glasses')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('tellHumanAboutGlasses@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule tellHumanAboutMilk
	def tellHumanAboutMilk(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for conth
			symbol_conth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'conth'] in equiv[0] and equiv[1] != None:
					symbol_conth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for contr
			symbol_contr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'contr'] in equiv[0] and equiv[1] != None:
					symbol_contr_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_conth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_contr_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_statusr_name in symbol_statusr_nodes:
					symbol_statusr = nodes[symbol_statusr_name]
					n2id['statusr'] = symbol_statusr_name
					if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"milk"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and symbol_robot.name!=symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_contr_name in symbol_contr_nodes:
									symbol_contr = nodes[symbol_contr_name]
									n2id['contr'] = symbol_contr_name
									if symbol_contr.sType == 'object' and symbol_contr.name!=symbol_objectr.name and symbol_contr.name!=symbol_statusr.name and symbol_contr.name!=symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_statusr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links:
												for symbol_conth_name in symbol_conth_nodes:
													symbol_conth = nodes[symbol_conth_name]
													n2id['conth'] = symbol_conth_name
													if symbol_conth.sType == 'object' and symbol_conth.name!=symbol_objectr.name and symbol_conth.name!=symbol_statusr.name and symbol_conth.name!=symbol_robot.name and symbol_conth.name!=symbol_contr.name and symbol_conth.name!=symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.tellHumanAboutMilk_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for contr...
															for equiv in equivalences2:
																if [me, 'contr'] in equiv[0]:
																	equiv[1] = symbol_contr_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for conth...
															for equiv in equivalences2:
																if [me, 'conth'] in equiv[0]:
																	equiv[1] = symbol_conth_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule tellHumanAboutMilk
	def tellHumanAboutMilk_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutMilk_trigger1')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"milk"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('tellHumanAboutMilk_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and test_symbol_robot.name!=test_symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('tellHumanAboutMilk_trigger3')
			test_symbol_contr = snode.graph.nodes[n2id['contr']]
			if not (test_symbol_contr.sType == 'object' and test_symbol_contr.name!=test_symbol_objectr.name and test_symbol_contr.name!=test_symbol_statusr.name and test_symbol_contr.name!=test_symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_contr(',n2id['contr'],').sType == object' , test_symbol_contr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutMilk_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_statusr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('tellHumanAboutMilk_trigger5')
			test_symbol_conth = snode.graph.nodes[n2id['conth']]
			if not (test_symbol_conth.sType == 'object' and test_symbol_conth.name!=test_symbol_objectr.name and test_symbol_conth.name!=test_symbol_statusr.name and test_symbol_conth.name!=test_symbol_robot.name and test_symbol_conth.name!=test_symbol_contr.name and test_symbol_conth.name!=test_symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_conth(',n2id['conth'],').sType == object' , test_symbol_conth.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutMilk_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'objecth' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['objecth'] = newName
		newNode.graph.nodes[n2id['objecth']] = AGMSymbol(n2id['objecth'], 'object')
		if not 'statush' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['statush'] = newName
		newNode.graph.nodes[n2id['statush']] = AGMSymbol(n2id['statush'], 'objectSt')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['person'], n2id['objecth'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['objecth'], 'eq')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['conth'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'milk')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('tellHumanAboutMilk@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule tellHumanAboutCoffeePot
	def tellHumanAboutCoffeePot(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for conth
			symbol_conth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'conth'] in equiv[0] and equiv[1] != None:
					symbol_conth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for contr
			symbol_contr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'contr'] in equiv[0] and equiv[1] != None:
					symbol_contr_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_conth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_contr_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_statusr_name in symbol_statusr_nodes:
					symbol_statusr = nodes[symbol_statusr_name]
					n2id['statusr'] = symbol_statusr_name
					if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"coffeepot"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and symbol_robot.name!=symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_contr_name in symbol_contr_nodes:
									symbol_contr = nodes[symbol_contr_name]
									n2id['contr'] = symbol_contr_name
									if symbol_contr.sType == 'object' and symbol_contr.name!=symbol_objectr.name and symbol_contr.name!=symbol_statusr.name and symbol_contr.name!=symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_statusr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links:
												for symbol_conth_name in symbol_conth_nodes:
													symbol_conth = nodes[symbol_conth_name]
													n2id['conth'] = symbol_conth_name
													if symbol_conth.sType == 'object' and symbol_conth.name!=symbol_objectr.name and symbol_conth.name!=symbol_statusr.name and symbol_conth.name!=symbol_robot.name and symbol_conth.name!=symbol_contr.name and symbol_conth.name!=symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.tellHumanAboutCoffeePot_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for contr...
															for equiv in equivalences2:
																if [me, 'contr'] in equiv[0]:
																	equiv[1] = symbol_contr_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for conth...
															for equiv in equivalences2:
																if [me, 'conth'] in equiv[0]:
																	equiv[1] = symbol_conth_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule tellHumanAboutCoffeePot
	def tellHumanAboutCoffeePot_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutCoffeePot_trigger1')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"coffeepot"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('tellHumanAboutCoffeePot_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and test_symbol_robot.name!=test_symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('tellHumanAboutCoffeePot_trigger3')
			test_symbol_contr = snode.graph.nodes[n2id['contr']]
			if not (test_symbol_contr.sType == 'object' and test_symbol_contr.name!=test_symbol_objectr.name and test_symbol_contr.name!=test_symbol_statusr.name and test_symbol_contr.name!=test_symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_contr(',n2id['contr'],').sType == object' , test_symbol_contr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutCoffeePot_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_statusr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('tellHumanAboutCoffeePot_trigger5')
			test_symbol_conth = snode.graph.nodes[n2id['conth']]
			if not (test_symbol_conth.sType == 'object' and test_symbol_conth.name!=test_symbol_objectr.name and test_symbol_conth.name!=test_symbol_statusr.name and test_symbol_conth.name!=test_symbol_robot.name and test_symbol_conth.name!=test_symbol_contr.name and test_symbol_conth.name!=test_symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_conth(',n2id['conth'],').sType == object' , test_symbol_conth.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutCoffeePot_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'objecth' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['objecth'] = newName
		newNode.graph.nodes[n2id['objecth']] = AGMSymbol(n2id['objecth'], 'object')
		if not 'statush' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['statush'] = newName
		newNode.graph.nodes[n2id['statush']] = AGMSymbol(n2id['statush'], 'objectSt')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['person'], n2id['objecth'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['objecth'], 'eq')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['conth'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'coffeepot')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('tellHumanAboutCoffeePot@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule tellHumanAboutTable
	def tellHumanAboutTable(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for conth
			symbol_conth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'conth'] in equiv[0] and equiv[1] != None:
					symbol_conth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for contr
			symbol_contr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'contr'] in equiv[0] and equiv[1] != None:
					symbol_contr_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_conth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_contr_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_statusr_name in symbol_statusr_nodes:
					symbol_statusr = nodes[symbol_statusr_name]
					n2id['statusr'] = symbol_statusr_name
					if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"table"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and symbol_robot.name!=symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_contr_name in symbol_contr_nodes:
									symbol_contr = nodes[symbol_contr_name]
									n2id['contr'] = symbol_contr_name
									if symbol_contr.sType == 'object' and symbol_contr.name!=symbol_objectr.name and symbol_contr.name!=symbol_statusr.name and symbol_contr.name!=symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_statusr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links:
												for symbol_conth_name in symbol_conth_nodes:
													symbol_conth = nodes[symbol_conth_name]
													n2id['conth'] = symbol_conth_name
													if symbol_conth.sType == 'object' and symbol_conth.name!=symbol_objectr.name and symbol_conth.name!=symbol_statusr.name and symbol_conth.name!=symbol_robot.name and symbol_conth.name!=symbol_contr.name and symbol_conth.name!=symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.tellHumanAboutTable_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for contr...
															for equiv in equivalences2:
																if [me, 'contr'] in equiv[0]:
																	equiv[1] = symbol_contr_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for conth...
															for equiv in equivalences2:
																if [me, 'conth'] in equiv[0]:
																	equiv[1] = symbol_conth_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule tellHumanAboutTable
	def tellHumanAboutTable_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutTable_trigger1')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classified"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"table"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('tellHumanAboutTable_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and test_symbol_robot.name!=test_symbol_statusr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('tellHumanAboutTable_trigger3')
			test_symbol_contr = snode.graph.nodes[n2id['contr']]
			if not (test_symbol_contr.sType == 'object' and test_symbol_contr.name!=test_symbol_objectr.name and test_symbol_contr.name!=test_symbol_statusr.name and test_symbol_contr.name!=test_symbol_robot.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_contr(',n2id['contr'],').sType == object' , test_symbol_contr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutTable_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_statusr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('tellHumanAboutTable_trigger5')
			test_symbol_conth = snode.graph.nodes[n2id['conth']]
			if not (test_symbol_conth.sType == 'object' and test_symbol_conth.name!=test_symbol_objectr.name and test_symbol_conth.name!=test_symbol_statusr.name and test_symbol_conth.name!=test_symbol_robot.name and test_symbol_conth.name!=test_symbol_contr.name and test_symbol_conth.name!=test_symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_conth(',n2id['conth'],').sType == object' , test_symbol_conth.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutTable_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'objecth' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['objecth'] = newName
		newNode.graph.nodes[n2id['objecth']] = AGMSymbol(n2id['objecth'], 'object')
		if not 'statush' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['statush'] = newName
		newNode.graph.nodes[n2id['statush']] = AGMSymbol(n2id['statush'], 'objectSt')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['person'], n2id['objecth'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['objecth'], 'eq')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['conth'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'table')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reach')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('tellHumanAboutTable@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule tellHumanAboutUnknownObject
	def tellHumanAboutUnknownObject(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for conth
			symbol_conth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'conth'] in equiv[0] and equiv[1] != None:
					symbol_conth_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for contr
			symbol_contr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'contr'] in equiv[0] and equiv[1] != None:
					symbol_contr_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_conth_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_contr_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_robot_name in symbol_robot_nodes:
					symbol_robot = nodes[symbol_robot_name]
					n2id['robot'] = symbol_robot_name
					if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
						for symbol_statusr_name in symbol_statusr_nodes:
							symbol_statusr = nodes[symbol_statusr_name]
							n2id['statusr'] = symbol_statusr_name
							if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and symbol_statusr.name!=symbol_robot.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links:
								for symbol_contr_name in symbol_contr_nodes:
									symbol_contr = nodes[symbol_contr_name]
									n2id['contr'] = symbol_contr_name
									if symbol_contr.sType == 'object' and symbol_contr.name!=symbol_objectr.name and symbol_contr.name!=symbol_robot.name and symbol_contr.name!=symbol_statusr.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_statusr.name and symbol_person.name!=symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links:
												for symbol_conth_name in symbol_conth_nodes:
													symbol_conth = nodes[symbol_conth_name]
													n2id['conth'] = symbol_conth_name
													if symbol_conth.sType == 'object' and symbol_conth.name!=symbol_objectr.name and symbol_conth.name!=symbol_robot.name and symbol_conth.name!=symbol_statusr.name and symbol_conth.name!=symbol_contr.name and symbol_conth.name!=symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.tellHumanAboutUnknownObject_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for contr...
															for equiv in equivalences2:
																if [me, 'contr'] in equiv[0]:
																	equiv[1] = symbol_contr_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for conth...
															for equiv in equivalences2:
																if [me, 'conth'] in equiv[0]:
																	equiv[1] = symbol_conth_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule tellHumanAboutUnknownObject
	def tellHumanAboutUnknownObject_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutUnknownObject_trigger1')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('tellHumanAboutUnknownObject_trigger2')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and test_symbol_statusr.name!=test_symbol_robot.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('tellHumanAboutUnknownObject_trigger3')
			test_symbol_contr = snode.graph.nodes[n2id['contr']]
			if not (test_symbol_contr.sType == 'object' and test_symbol_contr.name!=test_symbol_objectr.name and test_symbol_contr.name!=test_symbol_robot.name and test_symbol_contr.name!=test_symbol_statusr.name and [n2id["objectr"],n2id["contr"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_contr(',n2id['contr'],').sType == object' , test_symbol_contr.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutUnknownObject_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_statusr.name and test_symbol_person.name!=test_symbol_contr.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('tellHumanAboutUnknownObject_trigger5')
			test_symbol_conth = snode.graph.nodes[n2id['conth']]
			if not (test_symbol_conth.sType == 'object' and test_symbol_conth.name!=test_symbol_objectr.name and test_symbol_conth.name!=test_symbol_robot.name and test_symbol_conth.name!=test_symbol_statusr.name and test_symbol_conth.name!=test_symbol_contr.name and test_symbol_conth.name!=test_symbol_person.name and [n2id["contr"],n2id["conth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_conth(',n2id['conth'],').sType == object' , test_symbol_conth.sType == 'object'
				raise WrongRuleExecution('tellHumanAboutUnknownObject_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		if not 'objecth' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['objecth'] = newName
		newNode.graph.nodes[n2id['objecth']] = AGMSymbol(n2id['objecth'], 'object')
		if not 'statush' in n2id:
			newName = str(getNewIdForSymbol(newNode))
			n2id['statush'] = newName
		newNode.graph.nodes[n2id['statush']] = AGMSymbol(n2id['statush'], 'objectSt')
		# Retype nodes
		# Remove nodes
		# Remove links
		# Create links
		l = AGMLink(n2id['person'], n2id['objecth'], 'know')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'hasStatus')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['objecth'], 'eq')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'unclassified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'position')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['statush'], 'reachable')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['conth'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('tellHumanAboutUnknownObject@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule makeHumanLook
	def makeHumanLook(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for statush
			symbol_statush_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statush'] in equiv[0] and equiv[1] != None:
					symbol_statush_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_statush_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_objecth_name in symbol_objecth_nodes:
					symbol_objecth = nodes[symbol_objecth_name]
					n2id['objecth'] = symbol_objecth_name
					if symbol_objecth.sType == 'object' and symbol_objecth.name!=symbol_objectr.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and symbol_robot.name!=symbol_objecth.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_person_name in symbol_person_nodes:
									symbol_person = nodes[symbol_person_name]
									n2id['person'] = symbol_person_name
									if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_objecth.name and symbol_person.name!=symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links:
										for symbol_statusr_name in symbol_statusr_nodes:
											symbol_statusr = nodes[symbol_statusr_name]
											n2id['statusr'] = symbol_statusr_name
											if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and symbol_statusr.name!=symbol_objecth.name and symbol_statusr.name!=symbol_robot.name and symbol_statusr.name!=symbol_person.name and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"see"] in snode.graph.links:
												for symbol_statush_name in symbol_statush_nodes:
													symbol_statush = nodes[symbol_statush_name]
													n2id['statush'] = symbol_statush_name
													if symbol_statush.sType == 'objectSt' and symbol_statush.name!=symbol_objectr.name and symbol_statush.name!=symbol_objecth.name and symbol_statush.name!=symbol_robot.name and symbol_statush.name!=symbol_person.name and symbol_statush.name!=symbol_statusr.name and [n2id["objecth"],n2id["statush"],"noSee"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"position"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.makeHumanLook_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for objecth...
															for equiv in equivalences2:
																if [me, 'objecth'] in equiv[0]:
																	equiv[1] = symbol_objecth_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for statush...
															for equiv in equivalences2:
																if [me, 'statush'] in equiv[0]:
																	equiv[1] = symbol_statush_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule makeHumanLook
	def makeHumanLook_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('makeHumanLook_trigger1')
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object' and test_symbol_objecth.name!=test_symbol_objectr.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('makeHumanLook_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and test_symbol_robot.name!=test_symbol_objecth.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('makeHumanLook_trigger3')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_objecth.name and test_symbol_person.name!=test_symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('makeHumanLook_trigger4')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and test_symbol_statusr.name!=test_symbol_objecth.name and test_symbol_statusr.name!=test_symbol_robot.name and test_symbol_statusr.name!=test_symbol_person.name and [n2id["objectr"],n2id["statusr"],"position"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"see"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('makeHumanLook_trigger5')
			test_symbol_statush = snode.graph.nodes[n2id['statush']]
			if not (test_symbol_statush.sType == 'objectSt' and test_symbol_statush.name!=test_symbol_objectr.name and test_symbol_statush.name!=test_symbol_objecth.name and test_symbol_statush.name!=test_symbol_robot.name and test_symbol_statush.name!=test_symbol_person.name and test_symbol_statush.name!=test_symbol_statusr.name and [n2id["objecth"],n2id["statush"],"noSee"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"position"] in snode.graph.links):
				if verbose: print 'test_symbol_statush(',n2id['statush'],').sType == objectSt' , test_symbol_statush.sType == 'objectSt'
				raise WrongRuleExecution('makeHumanLook_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objecth'], n2id['statush'], 'noSee'] ]]
		# Create links
		l = AGMLink(n2id['objecth'], n2id['statush'], 'see')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 2
			newNode.depth += 1
		newNode.history.append('makeHumanLook@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule personClassifiesMug
	def personClassifiesMug(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for cont2
			symbol_cont2_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'cont2'] in equiv[0] and equiv[1] != None:
					symbol_cont2_nodes = [equiv[1]]
			# Find equivalence for statush
			symbol_statush_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statush'] in equiv[0] and equiv[1] != None:
					symbol_statush_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_cont2_nodes = symbol_nodes_copy
			symbol_statush_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objecth_name in symbol_objecth_nodes:
			symbol_objecth = nodes[symbol_objecth_name]
			n2id['objecth'] = symbol_objecth_name
			if symbol_objecth.sType == 'object':
				for symbol_statush_name in symbol_statush_nodes:
					symbol_statush = nodes[symbol_statush_name]
					n2id['statush'] = symbol_statush_name
					if symbol_statush.sType == 'objectSt' and symbol_statush.name!=symbol_objecth.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"unclassified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"see"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"position"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objecth.name and symbol_robot.name!=symbol_statush.name:
								for symbol_person_name in symbol_person_nodes:
									symbol_person = nodes[symbol_person_name]
									n2id['person'] = symbol_person_name
									if symbol_person.sType == 'person' and symbol_person.name!=symbol_objecth.name and symbol_person.name!=symbol_statush.name and symbol_person.name!=symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links:
										for symbol_objectr_name in symbol_objectr_nodes:
											symbol_objectr = nodes[symbol_objectr_name]
											n2id['objectr'] = symbol_objectr_name
											if symbol_objectr.sType == 'object' and symbol_objectr.name!=symbol_objecth.name and symbol_objectr.name!=symbol_statush.name and symbol_objectr.name!=symbol_robot.name and symbol_objectr.name!=symbol_person.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
												for symbol_cont2_name in symbol_cont2_nodes:
													symbol_cont2 = nodes[symbol_cont2_name]
													n2id['cont2'] = symbol_cont2_name
													if symbol_cont2.sType == 'object' and symbol_cont2.name!=symbol_objecth.name and symbol_cont2.name!=symbol_statush.name and symbol_cont2.name!=symbol_robot.name and symbol_cont2.name!=symbol_person.name and symbol_cont2.name!=symbol_objectr.name:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.personClassifiesMug_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objecth...
															for equiv in equivalences2:
																if [me, 'objecth'] in equiv[0]:
																	equiv[1] = symbol_objecth_name
															# Set symbol for statush...
															for equiv in equivalences2:
																if [me, 'statush'] in equiv[0]:
																	equiv[1] = symbol_statush_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for cont2...
															for equiv in equivalences2:
																if [me, 'cont2'] in equiv[0]:
																	equiv[1] = symbol_cont2_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule personClassifiesMug
	def personClassifiesMug_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object'):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('personClassifiesMug_trigger1')
			test_symbol_statush = snode.graph.nodes[n2id['statush']]
			if not (test_symbol_statush.sType == 'objectSt' and test_symbol_statush.name!=test_symbol_objecth.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"unclassified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"see"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"position"] in snode.graph.links):
				if verbose: print 'test_symbol_statush(',n2id['statush'],').sType == objectSt' , test_symbol_statush.sType == 'objectSt'
				raise WrongRuleExecution('personClassifiesMug_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objecth.name and test_symbol_robot.name!=test_symbol_statush.name):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('personClassifiesMug_trigger3')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objecth.name and test_symbol_person.name!=test_symbol_statush.name and test_symbol_person.name!=test_symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('personClassifiesMug_trigger4')
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object' and test_symbol_objectr.name!=test_symbol_objecth.name and test_symbol_objectr.name!=test_symbol_statush.name and test_symbol_objectr.name!=test_symbol_robot.name and test_symbol_objectr.name!=test_symbol_person.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('personClassifiesMug_trigger5')
			test_symbol_cont2 = snode.graph.nodes[n2id['cont2']]
			if not (test_symbol_cont2.sType == 'object' and test_symbol_cont2.name!=test_symbol_objecth.name and test_symbol_cont2.name!=test_symbol_statush.name and test_symbol_cont2.name!=test_symbol_robot.name and test_symbol_cont2.name!=test_symbol_person.name and test_symbol_cont2.name!=test_symbol_objectr.name):
				if verbose: print 'test_symbol_cont2(',n2id['cont2'],').sType == object' , test_symbol_cont2.sType == 'object'
				raise WrongRuleExecution('personClassifiesMug_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objecth'], n2id['statush'], 'unclassified'] ]]
		# Create links
		l = AGMLink(n2id['objecth'], n2id['statush'], 'mug')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['cont2'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('personClassifiesMug@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule personClassifiesTable
	def personClassifiesTable(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for cont2
			symbol_cont2_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'cont2'] in equiv[0] and equiv[1] != None:
					symbol_cont2_nodes = [equiv[1]]
			# Find equivalence for statush
			symbol_statush_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statush'] in equiv[0] and equiv[1] != None:
					symbol_statush_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_cont2_nodes = symbol_nodes_copy
			symbol_statush_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objecth_name in symbol_objecth_nodes:
			symbol_objecth = nodes[symbol_objecth_name]
			n2id['objecth'] = symbol_objecth_name
			if symbol_objecth.sType == 'object':
				for symbol_statush_name in symbol_statush_nodes:
					symbol_statush = nodes[symbol_statush_name]
					n2id['statush'] = symbol_statush_name
					if symbol_statush.sType == 'objectSt' and symbol_statush.name!=symbol_objecth.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"unclassified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"see"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"position"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objecth.name and symbol_robot.name!=symbol_statush.name:
								for symbol_person_name in symbol_person_nodes:
									symbol_person = nodes[symbol_person_name]
									n2id['person'] = symbol_person_name
									if symbol_person.sType == 'person' and symbol_person.name!=symbol_objecth.name and symbol_person.name!=symbol_statush.name and symbol_person.name!=symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links:
										for symbol_objectr_name in symbol_objectr_nodes:
											symbol_objectr = nodes[symbol_objectr_name]
											n2id['objectr'] = symbol_objectr_name
											if symbol_objectr.sType == 'object' and symbol_objectr.name!=symbol_objecth.name and symbol_objectr.name!=symbol_statush.name and symbol_objectr.name!=symbol_robot.name and symbol_objectr.name!=symbol_person.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
												for symbol_cont2_name in symbol_cont2_nodes:
													symbol_cont2 = nodes[symbol_cont2_name]
													n2id['cont2'] = symbol_cont2_name
													if symbol_cont2.sType == 'object' and symbol_cont2.name!=symbol_objecth.name and symbol_cont2.name!=symbol_statush.name and symbol_cont2.name!=symbol_robot.name and symbol_cont2.name!=symbol_person.name and symbol_cont2.name!=symbol_objectr.name:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.personClassifiesTable_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objecth...
															for equiv in equivalences2:
																if [me, 'objecth'] in equiv[0]:
																	equiv[1] = symbol_objecth_name
															# Set symbol for statush...
															for equiv in equivalences2:
																if [me, 'statush'] in equiv[0]:
																	equiv[1] = symbol_statush_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for cont2...
															for equiv in equivalences2:
																if [me, 'cont2'] in equiv[0]:
																	equiv[1] = symbol_cont2_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule personClassifiesTable
	def personClassifiesTable_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object'):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('personClassifiesTable_trigger1')
			test_symbol_statush = snode.graph.nodes[n2id['statush']]
			if not (test_symbol_statush.sType == 'objectSt' and test_symbol_statush.name!=test_symbol_objecth.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"unclassified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"see"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"position"] in snode.graph.links):
				if verbose: print 'test_symbol_statush(',n2id['statush'],').sType == objectSt' , test_symbol_statush.sType == 'objectSt'
				raise WrongRuleExecution('personClassifiesTable_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objecth.name and test_symbol_robot.name!=test_symbol_statush.name):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('personClassifiesTable_trigger3')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objecth.name and test_symbol_person.name!=test_symbol_statush.name and test_symbol_person.name!=test_symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('personClassifiesTable_trigger4')
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object' and test_symbol_objectr.name!=test_symbol_objecth.name and test_symbol_objectr.name!=test_symbol_statush.name and test_symbol_objectr.name!=test_symbol_robot.name and test_symbol_objectr.name!=test_symbol_person.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('personClassifiesTable_trigger5')
			test_symbol_cont2 = snode.graph.nodes[n2id['cont2']]
			if not (test_symbol_cont2.sType == 'object' and test_symbol_cont2.name!=test_symbol_objecth.name and test_symbol_cont2.name!=test_symbol_statush.name and test_symbol_cont2.name!=test_symbol_robot.name and test_symbol_cont2.name!=test_symbol_person.name and test_symbol_cont2.name!=test_symbol_objectr.name):
				if verbose: print 'test_symbol_cont2(',n2id['cont2'],').sType == object' , test_symbol_cont2.sType == 'object'
				raise WrongRuleExecution('personClassifiesTable_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objecth'], n2id['statush'], 'unclassified'] ]]
		# Create links
		l = AGMLink(n2id['objecth'], n2id['statush'], 'table')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objecth'], n2id['cont2'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('personClassifiesTable@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule personClassifiesMilkPot
	def personClassifiesMilkPot(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for statush
			symbol_statush_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statush'] in equiv[0] and equiv[1] != None:
					symbol_statush_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_statush_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objectr_name in symbol_objectr_nodes:
			symbol_objectr = nodes[symbol_objectr_name]
			n2id['objectr'] = symbol_objectr_name
			if symbol_objectr.sType == 'object':
				for symbol_objecth_name in symbol_objecth_nodes:
					symbol_objecth = nodes[symbol_objecth_name]
					n2id['objecth'] = symbol_objecth_name
					if symbol_objecth.sType == 'object' and symbol_objecth.name!=symbol_objectr.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objectr.name and symbol_robot.name!=symbol_objecth.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_person_name in symbol_person_nodes:
									symbol_person = nodes[symbol_person_name]
									n2id['person'] = symbol_person_name
									if symbol_person.sType == 'person' and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_objecth.name and symbol_person.name!=symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links:
										for symbol_statusr_name in symbol_statusr_nodes:
											symbol_statusr = nodes[symbol_statusr_name]
											n2id['statusr'] = symbol_statusr_name
											if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objectr.name and symbol_statusr.name!=symbol_objecth.name and symbol_statusr.name!=symbol_robot.name and symbol_statusr.name!=symbol_person.name and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links:
												for symbol_statush_name in symbol_statush_nodes:
													symbol_statush = nodes[symbol_statush_name]
													n2id['statush'] = symbol_statush_name
													if symbol_statush.sType == 'objectSt' and symbol_statush.name!=symbol_objectr.name and symbol_statush.name!=symbol_objecth.name and symbol_statush.name!=symbol_robot.name and symbol_statush.name!=symbol_person.name and symbol_statush.name!=symbol_statusr.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"unclassified"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.personClassifiesMilkPot_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for objecth...
															for equiv in equivalences2:
																if [me, 'objecth'] in equiv[0]:
																	equiv[1] = symbol_objecth_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															# Set symbol for statush...
															for equiv in equivalences2:
																if [me, 'statush'] in equiv[0]:
																	equiv[1] = symbol_statush_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule personClassifiesMilkPot
	def personClassifiesMilkPot_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object'):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('personClassifiesMilkPot_trigger1')
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object' and test_symbol_objecth.name!=test_symbol_objectr.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('personClassifiesMilkPot_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objectr.name and test_symbol_robot.name!=test_symbol_objecth.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('personClassifiesMilkPot_trigger3')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_objecth.name and test_symbol_person.name!=test_symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('personClassifiesMilkPot_trigger4')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objectr.name and test_symbol_statusr.name!=test_symbol_objecth.name and test_symbol_statusr.name!=test_symbol_robot.name and test_symbol_statusr.name!=test_symbol_person.name and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('personClassifiesMilkPot_trigger5')
			test_symbol_statush = snode.graph.nodes[n2id['statush']]
			if not (test_symbol_statush.sType == 'objectSt' and test_symbol_statush.name!=test_symbol_objectr.name and test_symbol_statush.name!=test_symbol_objecth.name and test_symbol_statush.name!=test_symbol_robot.name and test_symbol_statush.name!=test_symbol_person.name and test_symbol_statush.name!=test_symbol_statusr.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"unclassified"] in snode.graph.links):
				if verbose: print 'test_symbol_statush(',n2id['statush'],').sType == objectSt' , test_symbol_statush.sType == 'objectSt'
				raise WrongRuleExecution('personClassifiesMilkPot_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objecth'], n2id['statush'], 'unclassified'], [n2id['objectr'], n2id['statusr'], 'classifailed'] ]]
		# Create links
		l = AGMLink(n2id['objecth'], n2id['statush'], 'milkpot')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['statusr'], 'milkpot')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('personClassifiesMilkPot@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule personTellsUsAboutMug
	def personTellsUsAboutMug(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for statush
			symbol_statush_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statush'] in equiv[0] and equiv[1] != None:
					symbol_statush_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_statush_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objecth_name in symbol_objecth_nodes:
			symbol_objecth = nodes[symbol_objecth_name]
			n2id['objecth'] = symbol_objecth_name
			if symbol_objecth.sType == 'object':
				for symbol_objectr_name in symbol_objectr_nodes:
					symbol_objectr = nodes[symbol_objectr_name]
					n2id['objectr'] = symbol_objectr_name
					if symbol_objectr.sType == 'object' and symbol_objectr.name!=symbol_objecth.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objecth.name and symbol_robot.name!=symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_statush_name in symbol_statush_nodes:
									symbol_statush = nodes[symbol_statush_name]
									n2id['statush'] = symbol_statush_name
									if symbol_statush.sType == 'objectSt' and symbol_statush.name!=symbol_objecth.name and symbol_statush.name!=symbol_objectr.name and symbol_statush.name!=symbol_robot.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"classified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"mug"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objecth.name and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_statush.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links:
												for symbol_statusr_name in symbol_statusr_nodes:
													symbol_statusr = nodes[symbol_statusr_name]
													n2id['statusr'] = symbol_statusr_name
													if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objecth.name and symbol_statusr.name!=symbol_objectr.name and symbol_statusr.name!=symbol_robot.name and symbol_statusr.name!=symbol_statush.name and symbol_statusr.name!=symbol_person.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.personTellsUsAboutMug_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objecth...
															for equiv in equivalences2:
																if [me, 'objecth'] in equiv[0]:
																	equiv[1] = symbol_objecth_name
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for statush...
															for equiv in equivalences2:
																if [me, 'statush'] in equiv[0]:
																	equiv[1] = symbol_statush_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule personTellsUsAboutMug
	def personTellsUsAboutMug_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object'):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('personTellsUsAboutMug_trigger1')
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object' and test_symbol_objectr.name!=test_symbol_objecth.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('personTellsUsAboutMug_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objecth.name and test_symbol_robot.name!=test_symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('personTellsUsAboutMug_trigger3')
			test_symbol_statush = snode.graph.nodes[n2id['statush']]
			if not (test_symbol_statush.sType == 'objectSt' and test_symbol_statush.name!=test_symbol_objecth.name and test_symbol_statush.name!=test_symbol_objectr.name and test_symbol_statush.name!=test_symbol_robot.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"classified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"mug"] in snode.graph.links):
				if verbose: print 'test_symbol_statush(',n2id['statush'],').sType == objectSt' , test_symbol_statush.sType == 'objectSt'
				raise WrongRuleExecution('personTellsUsAboutMug_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objecth.name and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_statush.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('personTellsUsAboutMug_trigger5')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objecth.name and test_symbol_statusr.name!=test_symbol_objectr.name and test_symbol_statusr.name!=test_symbol_robot.name and test_symbol_statusr.name!=test_symbol_statush.name and test_symbol_statusr.name!=test_symbol_person.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('personTellsUsAboutMug_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objectr'], n2id['statusr'], 'classifailed'] ]]
		# Create links
		l = AGMLink(n2id['objectr'], n2id['statusr'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['statusr'], 'mug')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('personTellsUsAboutMug@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule personTellsUsAboutMilkPot
	def personTellsUsAboutMilkPot(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for statush
			symbol_statush_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statush'] in equiv[0] and equiv[1] != None:
					symbol_statush_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_statush_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objecth_name in symbol_objecth_nodes:
			symbol_objecth = nodes[symbol_objecth_name]
			n2id['objecth'] = symbol_objecth_name
			if symbol_objecth.sType == 'object':
				for symbol_objectr_name in symbol_objectr_nodes:
					symbol_objectr = nodes[symbol_objectr_name]
					n2id['objectr'] = symbol_objectr_name
					if symbol_objectr.sType == 'object' and symbol_objectr.name!=symbol_objecth.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objecth.name and symbol_robot.name!=symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_statush_name in symbol_statush_nodes:
									symbol_statush = nodes[symbol_statush_name]
									n2id['statush'] = symbol_statush_name
									if symbol_statush.sType == 'objectSt' and symbol_statush.name!=symbol_objecth.name and symbol_statush.name!=symbol_objectr.name and symbol_statush.name!=symbol_robot.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"classified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"milkpot"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objecth.name and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_statush.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links:
												for symbol_statusr_name in symbol_statusr_nodes:
													symbol_statusr = nodes[symbol_statusr_name]
													n2id['statusr'] = symbol_statusr_name
													if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objecth.name and symbol_statusr.name!=symbol_objectr.name and symbol_statusr.name!=symbol_robot.name and symbol_statusr.name!=symbol_statush.name and symbol_statusr.name!=symbol_person.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.personTellsUsAboutMilkPot_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objecth...
															for equiv in equivalences2:
																if [me, 'objecth'] in equiv[0]:
																	equiv[1] = symbol_objecth_name
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for statush...
															for equiv in equivalences2:
																if [me, 'statush'] in equiv[0]:
																	equiv[1] = symbol_statush_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule personTellsUsAboutMilkPot
	def personTellsUsAboutMilkPot_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object'):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('personTellsUsAboutMilkPot_trigger1')
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object' and test_symbol_objectr.name!=test_symbol_objecth.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('personTellsUsAboutMilkPot_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objecth.name and test_symbol_robot.name!=test_symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('personTellsUsAboutMilkPot_trigger3')
			test_symbol_statush = snode.graph.nodes[n2id['statush']]
			if not (test_symbol_statush.sType == 'objectSt' and test_symbol_statush.name!=test_symbol_objecth.name and test_symbol_statush.name!=test_symbol_objectr.name and test_symbol_statush.name!=test_symbol_robot.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"classified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"milkpot"] in snode.graph.links):
				if verbose: print 'test_symbol_statush(',n2id['statush'],').sType == objectSt' , test_symbol_statush.sType == 'objectSt'
				raise WrongRuleExecution('personTellsUsAboutMilkPot_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objecth.name and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_statush.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('personTellsUsAboutMilkPot_trigger5')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objecth.name and test_symbol_statusr.name!=test_symbol_objectr.name and test_symbol_statusr.name!=test_symbol_robot.name and test_symbol_statusr.name!=test_symbol_statush.name and test_symbol_statusr.name!=test_symbol_person.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('personTellsUsAboutMilkPot_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objectr'], n2id['statusr'], 'classifailed'] ]]
		# Create links
		l = AGMLink(n2id['objectr'], n2id['statusr'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['statusr'], 'milkpot')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('personTellsUsAboutMilkPot@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule personTellsUsAboutTable
	def personTellsUsAboutTable(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for statusr
			symbol_statusr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statusr'] in equiv[0] and equiv[1] != None:
					symbol_statusr_nodes = [equiv[1]]
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for statush
			symbol_statush_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'statush'] in equiv[0] and equiv[1] != None:
					symbol_statush_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_statusr_nodes = symbol_nodes_copy
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_statush_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_objecth_name in symbol_objecth_nodes:
			symbol_objecth = nodes[symbol_objecth_name]
			n2id['objecth'] = symbol_objecth_name
			if symbol_objecth.sType == 'object':
				for symbol_objectr_name in symbol_objectr_nodes:
					symbol_objectr = nodes[symbol_objectr_name]
					n2id['objectr'] = symbol_objectr_name
					if symbol_objectr.sType == 'object' and symbol_objectr.name!=symbol_objecth.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links:
						for symbol_robot_name in symbol_robot_nodes:
							symbol_robot = nodes[symbol_robot_name]
							n2id['robot'] = symbol_robot_name
							if symbol_robot.sType == 'robot' and symbol_robot.name!=symbol_objecth.name and symbol_robot.name!=symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_statush_name in symbol_statush_nodes:
									symbol_statush = nodes[symbol_statush_name]
									n2id['statush'] = symbol_statush_name
									if symbol_statush.sType == 'objectSt' and symbol_statush.name!=symbol_objecth.name and symbol_statush.name!=symbol_objectr.name and symbol_statush.name!=symbol_robot.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"classified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"table"] in snode.graph.links:
										for symbol_person_name in symbol_person_nodes:
											symbol_person = nodes[symbol_person_name]
											n2id['person'] = symbol_person_name
											if symbol_person.sType == 'person' and symbol_person.name!=symbol_objecth.name and symbol_person.name!=symbol_objectr.name and symbol_person.name!=symbol_robot.name and symbol_person.name!=symbol_statush.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links:
												for symbol_statusr_name in symbol_statusr_nodes:
													symbol_statusr = nodes[symbol_statusr_name]
													n2id['statusr'] = symbol_statusr_name
													if symbol_statusr.sType == 'objectSt' and symbol_statusr.name!=symbol_objecth.name and symbol_statusr.name!=symbol_objectr.name and symbol_statusr.name!=symbol_robot.name and symbol_statusr.name!=symbol_statush.name and symbol_statusr.name!=symbol_person.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links:
														# At this point we meet all the conditions.
														stack2        = copy.deepcopy(stack)
														equivalences2 = copy.deepcopy(equivalences)
														r1 = self.personTellsUsAboutTable_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
														c = copy.deepcopy(r1)
														if 'fina' in locals():
															c.history.append(finishesCombo)
														if len(stack2) > 0: c.stop = True
														ret.append(c)
														if len(stack2) > 0:
															# Set symbol for objecth...
															for equiv in equivalences2:
																if [me, 'objecth'] in equiv[0]:
																	equiv[1] = symbol_objecth_name
															# Set symbol for objectr...
															for equiv in equivalences2:
																if [me, 'objectr'] in equiv[0]:
																	equiv[1] = symbol_objectr_name
															# Set symbol for robot...
															for equiv in equivalences2:
																if [me, 'robot'] in equiv[0]:
																	equiv[1] = symbol_robot_name
															# Set symbol for statush...
															for equiv in equivalences2:
																if [me, 'statush'] in equiv[0]:
																	equiv[1] = symbol_statush_name
															# Set symbol for person...
															for equiv in equivalences2:
																if [me, 'person'] in equiv[0]:
																	equiv[1] = symbol_person_name
															# Set symbol for statusr...
															for equiv in equivalences2:
																if [me, 'statusr'] in equiv[0]:
																	equiv[1] = symbol_statusr_name
															newNode = WorldStateHistory(r1)
															global lastNodeId
															lastNodeId += 1
															newNode.nodeId = lastNodeId
															derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
															if 'fina' in locals():
																for n in derivsx: n.history.append(finishesCombo)
																for n in derivsx: n.history.append(fina)
															ret.extend(derivsx)
		return ret
		
		

	# Rule personTellsUsAboutTable
	def personTellsUsAboutTable_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object'):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('personTellsUsAboutTable_trigger1')
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object' and test_symbol_objectr.name!=test_symbol_objecth.name and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('personTellsUsAboutTable_trigger2')
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot' and test_symbol_robot.name!=test_symbol_objecth.name and test_symbol_robot.name!=test_symbol_objectr.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('personTellsUsAboutTable_trigger3')
			test_symbol_statush = snode.graph.nodes[n2id['statush']]
			if not (test_symbol_statush.sType == 'objectSt' and test_symbol_statush.name!=test_symbol_objecth.name and test_symbol_statush.name!=test_symbol_objectr.name and test_symbol_statush.name!=test_symbol_robot.name and [n2id["objecth"],n2id["statush"],"hasStatus"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"classified"] in snode.graph.links and [n2id["objecth"],n2id["statush"],"table"] in snode.graph.links):
				if verbose: print 'test_symbol_statush(',n2id['statush'],').sType == objectSt' , test_symbol_statush.sType == 'objectSt'
				raise WrongRuleExecution('personTellsUsAboutTable_trigger4')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_objecth.name and test_symbol_person.name!=test_symbol_objectr.name and test_symbol_person.name!=test_symbol_robot.name and test_symbol_person.name!=test_symbol_statush.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('personTellsUsAboutTable_trigger5')
			test_symbol_statusr = snode.graph.nodes[n2id['statusr']]
			if not (test_symbol_statusr.sType == 'objectSt' and test_symbol_statusr.name!=test_symbol_objecth.name and test_symbol_statusr.name!=test_symbol_objectr.name and test_symbol_statusr.name!=test_symbol_robot.name and test_symbol_statusr.name!=test_symbol_statush.name and test_symbol_statusr.name!=test_symbol_person.name and [n2id["objectr"],n2id["statusr"],"hasStatus"] in snode.graph.links and [n2id["objectr"],n2id["statusr"],"classifailed"] in snode.graph.links):
				if verbose: print 'test_symbol_statusr(',n2id['statusr'],').sType == objectSt' , test_symbol_statusr.sType == 'objectSt'
				raise WrongRuleExecution('personTellsUsAboutTable_trigger6')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objectr'], n2id['statusr'], 'classifailed'] ]]
		# Create links
		l = AGMLink(n2id['objectr'], n2id['statusr'], 'classified')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		l = AGMLink(n2id['objectr'], n2id['statusr'], 'table')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 3
			newNode.depth += 1
		newNode.history.append('personTellsUsAboutTable@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule informHumanAboutMovedObject
	def informHumanAboutMovedObject(self, snode, stackP=None, equivalencesP=None):
		if stackP == None: stackP=[]
		if equivalencesP == None: equivalencesP=[]
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		symbol_nodes_copy = copy.deepcopy(snode.graph.nodes)
		finishesCombo = ''
		if len(stack) > 0:
			inCombo = True
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for cont2r
			symbol_cont2r_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'cont2r'] in equiv[0] and equiv[1] != None:
					symbol_cont2r_nodes = [equiv[1]]
			# Find equivalence for cont1r
			symbol_cont1r_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'cont1r'] in equiv[0] and equiv[1] != None:
					symbol_cont1r_nodes = [equiv[1]]
			# Find equivalence for objecth
			symbol_objecth_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objecth'] in equiv[0] and equiv[1] != None:
					symbol_objecth_nodes = [equiv[1]]
			# Find equivalence for robot
			symbol_robot_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'robot'] in equiv[0] and equiv[1] != None:
					symbol_robot_nodes = [equiv[1]]
			# Find equivalence for person
			symbol_person_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'person'] in equiv[0] and equiv[1] != None:
					symbol_person_nodes = [equiv[1]]
			# Find equivalence for objectr
			symbol_objectr_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'objectr'] in equiv[0] and equiv[1] != None:
					symbol_objectr_nodes = [equiv[1]]
			# Find equivalence for cont2h
			symbol_cont2h_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'cont2h'] in equiv[0] and equiv[1] != None:
					symbol_cont2h_nodes = [equiv[1]]
			# Find equivalence for cont1h
			symbol_cont1h_nodes = symbol_nodes_copy
			for equiv in equivalences:
				if [me, 'cont1h'] in equiv[0] and equiv[1] != None:
					symbol_cont1h_nodes = [equiv[1]]
		else:
			inCombo = False
			symbol_cont2r_nodes = symbol_nodes_copy
			symbol_cont1r_nodes = symbol_nodes_copy
			symbol_objecth_nodes = symbol_nodes_copy
			symbol_robot_nodes = symbol_nodes_copy
			symbol_person_nodes = symbol_nodes_copy
			symbol_objectr_nodes = symbol_nodes_copy
			symbol_cont2h_nodes = symbol_nodes_copy
			symbol_cont1h_nodes = symbol_nodes_copy
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_robot_name in symbol_robot_nodes:
			symbol_robot = nodes[symbol_robot_name]
			n2id['robot'] = symbol_robot_name
			if symbol_robot.sType == 'robot':
				for symbol_person_name in symbol_person_nodes:
					symbol_person = nodes[symbol_person_name]
					n2id['person'] = symbol_person_name
					if symbol_person.sType == 'person' and symbol_person.name!=symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links:
						for symbol_objectr_name in symbol_objectr_nodes:
							symbol_objectr = nodes[symbol_objectr_name]
							n2id['objectr'] = symbol_objectr_name
							if symbol_objectr.sType == 'object' and symbol_objectr.name!=symbol_robot.name and symbol_objectr.name!=symbol_person.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links:
								for symbol_objecth_name in symbol_objecth_nodes:
									symbol_objecth = nodes[symbol_objecth_name]
									n2id['objecth'] = symbol_objecth_name
									if symbol_objecth.sType == 'object' and symbol_objecth.name!=symbol_robot.name and symbol_objecth.name!=symbol_person.name and symbol_objecth.name!=symbol_objectr.name and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links:
										for symbol_cont1r_name in symbol_cont1r_nodes:
											symbol_cont1r = nodes[symbol_cont1r_name]
											n2id['cont1r'] = symbol_cont1r_name
											if symbol_cont1r.sType == 'object' and symbol_cont1r.name!=symbol_robot.name and symbol_cont1r.name!=symbol_person.name and symbol_cont1r.name!=symbol_objectr.name and symbol_cont1r.name!=symbol_objecth.name and [n2id["robot"],n2id["cont1r"],"know"] in snode.graph.links and [n2id["objectr"],n2id["cont1r"],"in"] in snode.graph.links:
												for symbol_cont2r_name in symbol_cont2r_nodes:
													symbol_cont2r = nodes[symbol_cont2r_name]
													n2id['cont2r'] = symbol_cont2r_name
													if symbol_cont2r.sType == 'object' and symbol_cont2r.name!=symbol_robot.name and symbol_cont2r.name!=symbol_person.name and symbol_cont2r.name!=symbol_objectr.name and symbol_cont2r.name!=symbol_objecth.name and symbol_cont2r.name!=symbol_cont1r.name and [n2id["robot"],n2id["cont2r"],"know"] in snode.graph.links:
														for symbol_cont2h_name in symbol_cont2h_nodes:
															symbol_cont2h = nodes[symbol_cont2h_name]
															n2id['cont2h'] = symbol_cont2h_name
															if symbol_cont2h.sType == 'object' and symbol_cont2h.name!=symbol_robot.name and symbol_cont2h.name!=symbol_person.name and symbol_cont2h.name!=symbol_objectr.name and symbol_cont2h.name!=symbol_objecth.name and symbol_cont2h.name!=symbol_cont1r.name and symbol_cont2h.name!=symbol_cont2r.name and [n2id["cont2r"],n2id["cont2h"],"eq"] in snode.graph.links and [n2id["person"],n2id["cont2h"],"know"] in snode.graph.links and [n2id["objecth"],n2id["cont2h"],"in"] in snode.graph.links:
																for symbol_cont1h_name in symbol_cont1h_nodes:
																	symbol_cont1h = nodes[symbol_cont1h_name]
																	n2id['cont1h'] = symbol_cont1h_name
																	if symbol_cont1h.sType == 'object' and symbol_cont1h.name!=symbol_robot.name and symbol_cont1h.name!=symbol_person.name and symbol_cont1h.name!=symbol_objectr.name and symbol_cont1h.name!=symbol_objecth.name and symbol_cont1h.name!=symbol_cont1r.name and symbol_cont1h.name!=symbol_cont2r.name and symbol_cont1h.name!=symbol_cont2h.name and [n2id["person"],n2id["cont1h"],"know"] in snode.graph.links and [n2id["cont1r"],n2id["cont1h"],"eq"] in snode.graph.links:
																		# At this point we meet all the conditions.
																		stack2        = copy.deepcopy(stack)
																		equivalences2 = copy.deepcopy(equivalences)
																		r1 = self.informHumanAboutMovedObject_trigger(snode, n2id, stack2, inCombo, equivalences2, copy.deepcopy(finishesCombo))
																		c = copy.deepcopy(r1)
																		if 'fina' in locals():
																			c.history.append(finishesCombo)
																		if len(stack2) > 0: c.stop = True
																		ret.append(c)
																		if len(stack2) > 0:
																			# Set symbol for robot...
																			for equiv in equivalences2:
																				if [me, 'robot'] in equiv[0]:
																					equiv[1] = symbol_robot_name
																			# Set symbol for person...
																			for equiv in equivalences2:
																				if [me, 'person'] in equiv[0]:
																					equiv[1] = symbol_person_name
																			# Set symbol for objectr...
																			for equiv in equivalences2:
																				if [me, 'objectr'] in equiv[0]:
																					equiv[1] = symbol_objectr_name
																			# Set symbol for objecth...
																			for equiv in equivalences2:
																				if [me, 'objecth'] in equiv[0]:
																					equiv[1] = symbol_objecth_name
																			# Set symbol for cont1r...
																			for equiv in equivalences2:
																				if [me, 'cont1r'] in equiv[0]:
																					equiv[1] = symbol_cont1r_name
																			# Set symbol for cont2r...
																			for equiv in equivalences2:
																				if [me, 'cont2r'] in equiv[0]:
																					equiv[1] = symbol_cont2r_name
																			# Set symbol for cont2h...
																			for equiv in equivalences2:
																				if [me, 'cont2h'] in equiv[0]:
																					equiv[1] = symbol_cont2h_name
																			# Set symbol for cont1h...
																			for equiv in equivalences2:
																				if [me, 'cont1h'] in equiv[0]:
																					equiv[1] = symbol_cont1h_name
																			newNode = WorldStateHistory(r1)
																			global lastNodeId
																			lastNodeId += 1
																			newNode.nodeId = lastNodeId
																			derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
																			if 'fina' in locals():
																				for n in derivsx: n.history.append(finishesCombo)
																				for n in derivsx: n.history.append(fina)
																			ret.extend(derivsx)
		return ret
		
		

	# Rule informHumanAboutMovedObject
	def informHumanAboutMovedObject_trigger(self, snode, n2id, stack=None, inCombo=False, equivalences=None, checked=True, finish='', verbose=False):
		if stack == None: stack=[]
		if equivalences == None: equivalences=[]
		if not checked:
			test_symbol_robot = snode.graph.nodes[n2id['robot']]
			if not (test_symbol_robot.sType == 'robot'):
				if verbose: print 'test_symbol_robot(',n2id['robot'],').sType == robot' , test_symbol_robot.sType == 'robot'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger1')
			test_symbol_person = snode.graph.nodes[n2id['person']]
			if not (test_symbol_person.sType == 'person' and test_symbol_person.name!=test_symbol_robot.name and [n2id["robot"],n2id["person"],"interacting"] in snode.graph.links):
				if verbose: print 'test_symbol_person(',n2id['person'],').sType == person' , test_symbol_person.sType == 'person'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger2')
			test_symbol_objectr = snode.graph.nodes[n2id['objectr']]
			if not (test_symbol_objectr.sType == 'object' and test_symbol_objectr.name!=test_symbol_robot.name and test_symbol_objectr.name!=test_symbol_person.name and [n2id["robot"],n2id["objectr"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_objectr(',n2id['objectr'],').sType == object' , test_symbol_objectr.sType == 'object'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger3')
			test_symbol_objecth = snode.graph.nodes[n2id['objecth']]
			if not (test_symbol_objecth.sType == 'object' and test_symbol_objecth.name!=test_symbol_robot.name and test_symbol_objecth.name!=test_symbol_person.name and test_symbol_objecth.name!=test_symbol_objectr.name and [n2id["person"],n2id["objecth"],"know"] in snode.graph.links and [n2id["objectr"],n2id["objecth"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_objecth(',n2id['objecth'],').sType == object' , test_symbol_objecth.sType == 'object'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger4')
			test_symbol_cont1r = snode.graph.nodes[n2id['cont1r']]
			if not (test_symbol_cont1r.sType == 'object' and test_symbol_cont1r.name!=test_symbol_robot.name and test_symbol_cont1r.name!=test_symbol_person.name and test_symbol_cont1r.name!=test_symbol_objectr.name and test_symbol_cont1r.name!=test_symbol_objecth.name and [n2id["robot"],n2id["cont1r"],"know"] in snode.graph.links and [n2id["objectr"],n2id["cont1r"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_cont1r(',n2id['cont1r'],').sType == object' , test_symbol_cont1r.sType == 'object'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger5')
			test_symbol_cont2r = snode.graph.nodes[n2id['cont2r']]
			if not (test_symbol_cont2r.sType == 'object' and test_symbol_cont2r.name!=test_symbol_robot.name and test_symbol_cont2r.name!=test_symbol_person.name and test_symbol_cont2r.name!=test_symbol_objectr.name and test_symbol_cont2r.name!=test_symbol_objecth.name and test_symbol_cont2r.name!=test_symbol_cont1r.name and [n2id["robot"],n2id["cont2r"],"know"] in snode.graph.links):
				if verbose: print 'test_symbol_cont2r(',n2id['cont2r'],').sType == object' , test_symbol_cont2r.sType == 'object'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger6')
			test_symbol_cont2h = snode.graph.nodes[n2id['cont2h']]
			if not (test_symbol_cont2h.sType == 'object' and test_symbol_cont2h.name!=test_symbol_robot.name and test_symbol_cont2h.name!=test_symbol_person.name and test_symbol_cont2h.name!=test_symbol_objectr.name and test_symbol_cont2h.name!=test_symbol_objecth.name and test_symbol_cont2h.name!=test_symbol_cont1r.name and test_symbol_cont2h.name!=test_symbol_cont2r.name and [n2id["cont2r"],n2id["cont2h"],"eq"] in snode.graph.links and [n2id["person"],n2id["cont2h"],"know"] in snode.graph.links and [n2id["objecth"],n2id["cont2h"],"in"] in snode.graph.links):
				if verbose: print 'test_symbol_cont2h(',n2id['cont2h'],').sType == object' , test_symbol_cont2h.sType == 'object'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger7')
			test_symbol_cont1h = snode.graph.nodes[n2id['cont1h']]
			if not (test_symbol_cont1h.sType == 'object' and test_symbol_cont1h.name!=test_symbol_robot.name and test_symbol_cont1h.name!=test_symbol_person.name and test_symbol_cont1h.name!=test_symbol_objectr.name and test_symbol_cont1h.name!=test_symbol_objecth.name and test_symbol_cont1h.name!=test_symbol_cont1r.name and test_symbol_cont1h.name!=test_symbol_cont2r.name and test_symbol_cont1h.name!=test_symbol_cont2h.name and [n2id["person"],n2id["cont1h"],"know"] in snode.graph.links and [n2id["cont1r"],n2id["cont1h"],"eq"] in snode.graph.links):
				if verbose: print 'test_symbol_cont1h(',n2id['cont1h'],').sType == object' , test_symbol_cont1h.sType == 'object'
				raise WrongRuleExecution('informHumanAboutMovedObject_trigger8')
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [n2id['objecth'], n2id['cont2h'], 'in'] ]]
		# Create links
		l = AGMLink(n2id['objecth'], n2id['cont1h'], 'in')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		if not inCombo:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('informHumanAboutMovedObject@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		
