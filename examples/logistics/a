import copy, sys
sys.path.append('/opt/robocomp/share')
from AGGL import *
from agglplanner import *

def getNewIdForSymbol(node):
	m = 1
	for k in node.graph.nodes:
			if int(node.graph.nodes[k].name) >= m:
				m = int(node.graph.nodes[k].name)+1
	return m

lastNodeId = 0

class RuleSet(object):
	def __init__(self):
		object.__init__(self)

	def getRules(self):
		mapping = dict()
		mapping['LOADTRUCK'] = self.LOADTRUCK
		mapping['UNLOADTRUCK'] = self.UNLOADTRUCK
		mapping['DRIVETRUCK'] = self.DRIVETRUCK
		mapping['LOADAIRPLANE'] = self.LOADAIRPLANE
		mapping['UNLOADAIRPLANE'] = self.UNLOADAIRPLANE
		mapping['FLYAIRPLANE'] = self.FLYAIRPLANE
		return mapping

	def getTriggers(self):
		mapping = dict()
		mapping['LOADTRUCK'] = self.LOADTRUCK_trigger
		mapping['UNLOADTRUCK'] = self.UNLOADTRUCK_trigger
		mapping['DRIVETRUCK'] = self.DRIVETRUCK_trigger
		mapping['LOADAIRPLANE'] = self.LOADAIRPLANE_trigger
		mapping['UNLOADAIRPLANE'] = self.UNLOADAIRPLANE_trigger
		mapping['FLYAIRPLANE'] = self.FLYAIRPLANE_trigger
		return mapping


	# Rule LOADTRUCK
	def LOADTRUCK(self, snode, stackP=[], equivalencesP=[]):
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		finishesCombo = ''
		if len(stack) > 0:
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for loc
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'loc'] in equiv[0]:
					if equiv[1] != None:
						symbol_loc_nodes = [equiv[1]]
			# Find equivalence for obj
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'obj'] in equiv[0]:
					if equiv[1] != None:
						symbol_obj_nodes = [equiv[1]]
			# Find equivalence for truck
			symbol_truck_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'truck'] in equiv[0]:
					if equiv[1] != None:
						symbol_truck_nodes = [equiv[1]]
		else:
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_truck_nodes = copy.deepcopy(snode.graph.nodes)
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_truck_name in symbol_truck_nodes:
			symbol_truck = nodes[symbol_truck_name]
			n2id['truck'] = symbol_truck_name
			if symbol_truck.sType == 'TRCK':
				for symbol_obj_name in symbol_obj_nodes:
					symbol_obj = nodes[symbol_obj_name]
					n2id['obj'] = symbol_obj_name
					if symbol_obj.sType == 'OBJ' and symbol_obj.name!=symbol_truck.name:
						for symbol_loc_name in symbol_loc_nodes:
							symbol_loc = nodes[symbol_loc_name]
							n2id['loc'] = symbol_loc_name
							if symbol_loc.sType == 'LCTN' and symbol_loc.name!=symbol_truck.name and symbol_loc.name!=symbol_obj.name and [n2id["truck"],n2id["loc"],"at"] in snode.graph.links and [n2id["obj"],n2id["loc"],"at"] in snode.graph.links:
								# At this point we meet all the conditions.
								# Insert additional conditions manually here if you want.
								# (beware that the code could be regenerated and you might lose your changes).
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.LOADTRUCK_trigger(snode, n2id, stack2, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for truck...
									for equiv in equivalences2:
										if [me, 'truck'] in equiv[0]:
											equiv[1] = symbol_truck_name
									# Set symbol for obj...
									for equiv in equivalences2:
										if [me, 'obj'] in equiv[0]:
											equiv[1] = symbol_obj_name
									# Set symbol for loc...
									for equiv in equivalences2:
										if [me, 'loc'] in equiv[0]:
											equiv[1] = symbol_loc_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									newNode.parentId = snode.nodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule LOADTRUCK
	def LOADTRUCK_trigger(self, snode, n2id, stack=[], equivalences=[], checked=True, finish=''):
		if not checked:
			test_symbol_truck = snode.graph.nodes[n2id['truck']]
			if not (test_symbol_truck.sType == 'TRCK'):
				raise WrongRuleExecution('LOADTRUCK_trigger1 ')
			test_symbol_obj = snode.graph.nodes[n2id['obj']]
			if not (test_symbol_obj.sType == 'OBJ' and test_symbol_obj.name!=test_symbol_truck.name):
				raise WrongRuleExecution('LOADTRUCK_trigger2 ')
			test_symbol_loc = snode.graph.nodes[n2id['loc']]
			if not (test_symbol_loc.sType == 'LCTN' and test_symbol_loc.name!=test_symbol_truck.name and test_symbol_loc.name!=test_symbol_obj.name and [n2id["truck"],n2id["loc"],"at"] in snode.graph.links and [n2id["obj"],n2id["loc"],"at"] in snode.graph.links):
				raise WrongRuleExecution('LOADTRUCK_trigger3 ')
		smap = copy.deepcopy(n2id)
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		newNode.parentId = snode.nodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		newNode.graph.removeDanglingEdges()
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [smap['obj'], smap['loc'], 'at'] ]]
		# Create links
		l = AGMLink(smap['obj'], smap['truck'], 'at')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		newNode.probability *= 1.
		if len(stack) == 0:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('LOADTRUCK@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule UNLOADTRUCK
	def UNLOADTRUCK(self, snode, stackP=[], equivalencesP=[]):
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		finishesCombo = ''
		if len(stack) > 0:
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for loc
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'loc'] in equiv[0]:
					if equiv[1] != None:
						symbol_loc_nodes = [equiv[1]]
			# Find equivalence for obj
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'obj'] in equiv[0]:
					if equiv[1] != None:
						symbol_obj_nodes = [equiv[1]]
			# Find equivalence for truck
			symbol_truck_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'truck'] in equiv[0]:
					if equiv[1] != None:
						symbol_truck_nodes = [equiv[1]]
		else:
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_truck_nodes = copy.deepcopy(snode.graph.nodes)
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_truck_name in symbol_truck_nodes:
			symbol_truck = nodes[symbol_truck_name]
			n2id['truck'] = symbol_truck_name
			if symbol_truck.sType == 'TRCK':
				for symbol_obj_name in symbol_obj_nodes:
					symbol_obj = nodes[symbol_obj_name]
					n2id['obj'] = symbol_obj_name
					if symbol_obj.sType == 'OBJ' and symbol_obj.name!=symbol_truck.name and [n2id["obj"],n2id["truck"],"at"] in snode.graph.links:
						for symbol_loc_name in symbol_loc_nodes:
							symbol_loc = nodes[symbol_loc_name]
							n2id['loc'] = symbol_loc_name
							if symbol_loc.sType == 'LCTN' and symbol_loc.name!=symbol_truck.name and symbol_loc.name!=symbol_obj.name and [n2id["truck"],n2id["loc"],"at"] in snode.graph.links:
								# At this point we meet all the conditions.
								# Insert additional conditions manually here if you want.
								# (beware that the code could be regenerated and you might lose your changes).
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.UNLOADTRUCK_trigger(snode, n2id, stack2, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for truck...
									for equiv in equivalences2:
										if [me, 'truck'] in equiv[0]:
											equiv[1] = symbol_truck_name
									# Set symbol for obj...
									for equiv in equivalences2:
										if [me, 'obj'] in equiv[0]:
											equiv[1] = symbol_obj_name
									# Set symbol for loc...
									for equiv in equivalences2:
										if [me, 'loc'] in equiv[0]:
											equiv[1] = symbol_loc_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									newNode.parentId = snode.nodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule UNLOADTRUCK
	def UNLOADTRUCK_trigger(self, snode, n2id, stack=[], equivalences=[], checked=True, finish=''):
		if not checked:
			test_symbol_truck = snode.graph.nodes[n2id['truck']]
			if not (test_symbol_truck.sType == 'TRCK'):
				raise WrongRuleExecution('UNLOADTRUCK_trigger1 ')
			test_symbol_obj = snode.graph.nodes[n2id['obj']]
			if not (test_symbol_obj.sType == 'OBJ' and test_symbol_obj.name!=test_symbol_truck.name and [n2id["obj"],n2id["truck"],"at"] in snode.graph.links):
				raise WrongRuleExecution('UNLOADTRUCK_trigger2 ')
			test_symbol_loc = snode.graph.nodes[n2id['loc']]
			if not (test_symbol_loc.sType == 'LCTN' and test_symbol_loc.name!=test_symbol_truck.name and test_symbol_loc.name!=test_symbol_obj.name and [n2id["truck"],n2id["loc"],"at"] in snode.graph.links):
				raise WrongRuleExecution('UNLOADTRUCK_trigger3 ')
		smap = copy.deepcopy(n2id)
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		newNode.parentId = snode.nodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		newNode.graph.removeDanglingEdges()
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [smap['obj'], smap['truck'], 'at'] ]]
		# Create links
		l = AGMLink(smap['obj'], smap['loc'], 'at')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		newNode.probability *= 1.
		if len(stack) == 0:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('UNLOADTRUCK@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule DRIVETRUCK
	def DRIVETRUCK(self, snode, stackP=[], equivalencesP=[]):
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		finishesCombo = ''
		if len(stack) > 0:
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for lo2
			symbol_lo2_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'lo2'] in equiv[0]:
					if equiv[1] != None:
						symbol_lo2_nodes = [equiv[1]]
			# Find equivalence for ci
			symbol_ci_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'ci'] in equiv[0]:
					if equiv[1] != None:
						symbol_ci_nodes = [equiv[1]]
			# Find equivalence for lo1
			symbol_lo1_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'lo1'] in equiv[0]:
					if equiv[1] != None:
						symbol_lo1_nodes = [equiv[1]]
			# Find equivalence for tr
			symbol_tr_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'tr'] in equiv[0]:
					if equiv[1] != None:
						symbol_tr_nodes = [equiv[1]]
		else:
			symbol_lo2_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_ci_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_lo1_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_tr_nodes = copy.deepcopy(snode.graph.nodes)
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_lo1_name in symbol_lo1_nodes:
			symbol_lo1 = nodes[symbol_lo1_name]
			n2id['lo1'] = symbol_lo1_name
			if symbol_lo1.sType == 'LCTN':
				for symbol_tr_name in symbol_tr_nodes:
					symbol_tr = nodes[symbol_tr_name]
					n2id['tr'] = symbol_tr_name
					if symbol_tr.sType == 'TRCK' and symbol_tr.name!=symbol_lo1.name and [n2id["tr"],n2id["lo1"],"at"] in snode.graph.links:
						for symbol_lo2_name in symbol_lo2_nodes:
							symbol_lo2 = nodes[symbol_lo2_name]
							n2id['lo2'] = symbol_lo2_name
							if symbol_lo2.sType == 'LCTN' and symbol_lo2.name!=symbol_lo1.name and symbol_lo2.name!=symbol_tr.name:
								for symbol_ci_name in symbol_ci_nodes:
									symbol_ci = nodes[symbol_ci_name]
									n2id['ci'] = symbol_ci_name
									if symbol_ci.sType == 'CITY' and symbol_ci.name!=symbol_lo1.name and symbol_ci.name!=symbol_tr.name and symbol_ci.name!=symbol_lo2.name and [n2id["lo1"],n2id["ci"],"inCity"] in snode.graph.links and [n2id["lo2"],n2id["ci"],"inCity"] in snode.graph.links:
										# At this point we meet all the conditions.
										# Insert additional conditions manually here if you want.
										# (beware that the code could be regenerated and you might lose your changes).
										stack2        = copy.deepcopy(stack)
										equivalences2 = copy.deepcopy(equivalences)
										r1 = self.DRIVETRUCK_trigger(snode, n2id, stack2, equivalences2, copy.deepcopy(finishesCombo))
										c = copy.deepcopy(r1)
										if 'fina' in locals():
											c.history.append(finishesCombo)
										if len(stack2) > 0: c.stop = True
										ret.append(c)
										if len(stack2) > 0:
											# Set symbol for lo1...
											for equiv in equivalences2:
												if [me, 'lo1'] in equiv[0]:
													equiv[1] = symbol_lo1_name
											# Set symbol for tr...
											for equiv in equivalences2:
												if [me, 'tr'] in equiv[0]:
													equiv[1] = symbol_tr_name
											# Set symbol for lo2...
											for equiv in equivalences2:
												if [me, 'lo2'] in equiv[0]:
													equiv[1] = symbol_lo2_name
											# Set symbol for ci...
											for equiv in equivalences2:
												if [me, 'ci'] in equiv[0]:
													equiv[1] = symbol_ci_name
											newNode = WorldStateHistory(r1)
											global lastNodeId
											lastNodeId += 1
											newNode.nodeId = lastNodeId
											newNode.parentId = snode.nodeId
											derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
											if 'fina' in locals():
												for n in derivsx: n.history.append(finishesCombo)
												for n in derivsx: n.history.append(fina)
											ret.extend(derivsx)
		return ret
		
		

	# Rule DRIVETRUCK
	def DRIVETRUCK_trigger(self, snode, n2id, stack=[], equivalences=[], checked=True, finish=''):
		if not checked:
			test_symbol_lo1 = snode.graph.nodes[n2id['lo1']]
			if not (test_symbol_lo1.sType == 'LCTN'):
				raise WrongRuleExecution('DRIVETRUCK_trigger1 ')
			test_symbol_tr = snode.graph.nodes[n2id['tr']]
			if not (test_symbol_tr.sType == 'TRCK' and test_symbol_tr.name!=test_symbol_lo1.name and [n2id["tr"],n2id["lo1"],"at"] in snode.graph.links):
				raise WrongRuleExecution('DRIVETRUCK_trigger2 ')
			test_symbol_lo2 = snode.graph.nodes[n2id['lo2']]
			if not (test_symbol_lo2.sType == 'LCTN' and test_symbol_lo2.name!=test_symbol_lo1.name and test_symbol_lo2.name!=test_symbol_tr.name):
				raise WrongRuleExecution('DRIVETRUCK_trigger3 ')
			test_symbol_ci = snode.graph.nodes[n2id['ci']]
			if not (test_symbol_ci.sType == 'CITY' and test_symbol_ci.name!=test_symbol_lo1.name and test_symbol_ci.name!=test_symbol_tr.name and test_symbol_ci.name!=test_symbol_lo2.name and [n2id["lo1"],n2id["ci"],"inCity"] in snode.graph.links and [n2id["lo2"],n2id["ci"],"inCity"] in snode.graph.links):
				raise WrongRuleExecution('DRIVETRUCK_trigger4 ')
		smap = copy.deepcopy(n2id)
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		newNode.parentId = snode.nodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		newNode.graph.removeDanglingEdges()
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [smap['tr'], smap['lo1'], 'at'] ]]
		# Create links
		l = AGMLink(smap['tr'], smap['lo2'], 'at')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		newNode.probability *= 1.
		if len(stack) == 0:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('DRIVETRUCK@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule LOADAIRPLANE
	def LOADAIRPLANE(self, snode, stackP=[], equivalencesP=[]):
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		finishesCombo = ''
		if len(stack) > 0:
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for loc
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'loc'] in equiv[0]:
					if equiv[1] != None:
						symbol_loc_nodes = [equiv[1]]
			# Find equivalence for obj
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'obj'] in equiv[0]:
					if equiv[1] != None:
						symbol_obj_nodes = [equiv[1]]
			# Find equivalence for ap
			symbol_ap_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'ap'] in equiv[0]:
					if equiv[1] != None:
						symbol_ap_nodes = [equiv[1]]
		else:
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_ap_nodes = copy.deepcopy(snode.graph.nodes)
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_obj_name in symbol_obj_nodes:
			symbol_obj = nodes[symbol_obj_name]
			n2id['obj'] = symbol_obj_name
			if symbol_obj.sType == 'OBJ':
				for symbol_loc_name in symbol_loc_nodes:
					symbol_loc = nodes[symbol_loc_name]
					n2id['loc'] = symbol_loc_name
					if symbol_loc.sType == 'LCTN' and symbol_loc.name!=symbol_obj.name and [n2id["obj"],n2id["loc"],"at"] in snode.graph.links:
						for symbol_ap_name in symbol_ap_nodes:
							symbol_ap = nodes[symbol_ap_name]
							n2id['ap'] = symbol_ap_name
							if symbol_ap.sType == 'ARPL' and symbol_ap.name!=symbol_obj.name and symbol_ap.name!=symbol_loc.name and [n2id["ap"],n2id["loc"],"at"] in snode.graph.links:
								# At this point we meet all the conditions.
								# Insert additional conditions manually here if you want.
								# (beware that the code could be regenerated and you might lose your changes).
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.LOADAIRPLANE_trigger(snode, n2id, stack2, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for obj...
									for equiv in equivalences2:
										if [me, 'obj'] in equiv[0]:
											equiv[1] = symbol_obj_name
									# Set symbol for loc...
									for equiv in equivalences2:
										if [me, 'loc'] in equiv[0]:
											equiv[1] = symbol_loc_name
									# Set symbol for ap...
									for equiv in equivalences2:
										if [me, 'ap'] in equiv[0]:
											equiv[1] = symbol_ap_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									newNode.parentId = snode.nodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule LOADAIRPLANE
	def LOADAIRPLANE_trigger(self, snode, n2id, stack=[], equivalences=[], checked=True, finish=''):
		if not checked:
			test_symbol_obj = snode.graph.nodes[n2id['obj']]
			if not (test_symbol_obj.sType == 'OBJ'):
				raise WrongRuleExecution('LOADAIRPLANE_trigger1 ')
			test_symbol_loc = snode.graph.nodes[n2id['loc']]
			if not (test_symbol_loc.sType == 'LCTN' and test_symbol_loc.name!=test_symbol_obj.name and [n2id["obj"],n2id["loc"],"at"] in snode.graph.links):
				raise WrongRuleExecution('LOADAIRPLANE_trigger2 ')
			test_symbol_ap = snode.graph.nodes[n2id['ap']]
			if not (test_symbol_ap.sType == 'ARPL' and test_symbol_ap.name!=test_symbol_obj.name and test_symbol_ap.name!=test_symbol_loc.name and [n2id["ap"],n2id["loc"],"at"] in snode.graph.links):
				raise WrongRuleExecution('LOADAIRPLANE_trigger3 ')
		smap = copy.deepcopy(n2id)
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		newNode.parentId = snode.nodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		newNode.graph.removeDanglingEdges()
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [smap['obj'], smap['loc'], 'at'] ]]
		# Create links
		l = AGMLink(smap['obj'], smap['ap'], 'at')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		newNode.probability *= 1.
		if len(stack) == 0:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('LOADAIRPLANE@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule UNLOADAIRPLANE
	def UNLOADAIRPLANE(self, snode, stackP=[], equivalencesP=[]):
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		finishesCombo = ''
		if len(stack) > 0:
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for loc
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'loc'] in equiv[0]:
					if equiv[1] != None:
						symbol_loc_nodes = [equiv[1]]
			# Find equivalence for obj
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'obj'] in equiv[0]:
					if equiv[1] != None:
						symbol_obj_nodes = [equiv[1]]
			# Find equivalence for ap
			symbol_ap_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'ap'] in equiv[0]:
					if equiv[1] != None:
						symbol_ap_nodes = [equiv[1]]
		else:
			symbol_loc_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_obj_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_ap_nodes = copy.deepcopy(snode.graph.nodes)
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_ap_name in symbol_ap_nodes:
			symbol_ap = nodes[symbol_ap_name]
			n2id['ap'] = symbol_ap_name
			if symbol_ap.sType == 'ARPL':
				for symbol_obj_name in symbol_obj_nodes:
					symbol_obj = nodes[symbol_obj_name]
					n2id['obj'] = symbol_obj_name
					if symbol_obj.sType == 'OBJ' and symbol_obj.name!=symbol_ap.name and [n2id["obj"],n2id["ap"],"at"] in snode.graph.links:
						for symbol_loc_name in symbol_loc_nodes:
							symbol_loc = nodes[symbol_loc_name]
							n2id['loc'] = symbol_loc_name
							if symbol_loc.sType == 'LCTN' and symbol_loc.name!=symbol_ap.name and symbol_loc.name!=symbol_obj.name and [n2id["ap"],n2id["loc"],"at"] in snode.graph.links:
								# At this point we meet all the conditions.
								# Insert additional conditions manually here if you want.
								# (beware that the code could be regenerated and you might lose your changes).
								stack2        = copy.deepcopy(stack)
								equivalences2 = copy.deepcopy(equivalences)
								r1 = self.UNLOADAIRPLANE_trigger(snode, n2id, stack2, equivalences2, copy.deepcopy(finishesCombo))
								c = copy.deepcopy(r1)
								if 'fina' in locals():
									c.history.append(finishesCombo)
								if len(stack2) > 0: c.stop = True
								ret.append(c)
								if len(stack2) > 0:
									# Set symbol for ap...
									for equiv in equivalences2:
										if [me, 'ap'] in equiv[0]:
											equiv[1] = symbol_ap_name
									# Set symbol for obj...
									for equiv in equivalences2:
										if [me, 'obj'] in equiv[0]:
											equiv[1] = symbol_obj_name
									# Set symbol for loc...
									for equiv in equivalences2:
										if [me, 'loc'] in equiv[0]:
											equiv[1] = symbol_loc_name
									newNode = WorldStateHistory(r1)
									global lastNodeId
									lastNodeId += 1
									newNode.nodeId = lastNodeId
									newNode.parentId = snode.nodeId
									derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
									if 'fina' in locals():
										for n in derivsx: n.history.append(finishesCombo)
										for n in derivsx: n.history.append(fina)
									ret.extend(derivsx)
		return ret
		
		

	# Rule UNLOADAIRPLANE
	def UNLOADAIRPLANE_trigger(self, snode, n2id, stack=[], equivalences=[], checked=True, finish=''):
		if not checked:
			test_symbol_ap = snode.graph.nodes[n2id['ap']]
			if not (test_symbol_ap.sType == 'ARPL'):
				raise WrongRuleExecution('UNLOADAIRPLANE_trigger1 ')
			test_symbol_obj = snode.graph.nodes[n2id['obj']]
			if not (test_symbol_obj.sType == 'OBJ' and test_symbol_obj.name!=test_symbol_ap.name and [n2id["obj"],n2id["ap"],"at"] in snode.graph.links):
				raise WrongRuleExecution('UNLOADAIRPLANE_trigger2 ')
			test_symbol_loc = snode.graph.nodes[n2id['loc']]
			if not (test_symbol_loc.sType == 'LCTN' and test_symbol_loc.name!=test_symbol_ap.name and test_symbol_loc.name!=test_symbol_obj.name and [n2id["ap"],n2id["loc"],"at"] in snode.graph.links):
				raise WrongRuleExecution('UNLOADAIRPLANE_trigger3 ')
		smap = copy.deepcopy(n2id)
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		newNode.parentId = snode.nodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		newNode.graph.removeDanglingEdges()
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [smap['obj'], smap['ap'], 'at'] ]]
		# Create links
		l = AGMLink(smap['obj'], smap['loc'], 'at')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		newNode.probability *= 1.
		if len(stack) == 0:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('UNLOADAIRPLANE@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		

	# Rule FLYAIRPLANE
	def FLYAIRPLANE(self, snode, stackP=[], equivalencesP=[]):
		stack        = copy.deepcopy(stackP)
		equivalences = copy.deepcopy(equivalencesP)
		finishesCombo = ''
		if len(stack) > 0:
			pop = stack.pop()
			me = pop[0]
			if len(pop)>2:
				finishesCombo = copy.deepcopy(pop[2])
				fina = copy.deepcopy(pop[2])
			# Find equivalence for lo2
			symbol_lo2_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'lo2'] in equiv[0]:
					if equiv[1] != None:
						symbol_lo2_nodes = [equiv[1]]
			# Find equivalence for ap
			symbol_ap_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'ap'] in equiv[0]:
					if equiv[1] != None:
						symbol_ap_nodes = [equiv[1]]
			# Find equivalence for airport
			symbol_airport_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'airport'] in equiv[0]:
					if equiv[1] != None:
						symbol_airport_nodes = [equiv[1]]
			# Find equivalence for lo1
			symbol_lo1_nodes = copy.deepcopy(snode.graph.nodes)
			for equiv in equivalences:
				if [me, 'lo1'] in equiv[0]:
					if equiv[1] != None:
						symbol_lo1_nodes = [equiv[1]]
		else:
			symbol_lo2_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_ap_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_airport_nodes = copy.deepcopy(snode.graph.nodes)
			symbol_lo1_nodes = copy.deepcopy(snode.graph.nodes)
		ret = []
		nodes = copy.deepcopy(snode.graph.nodes)
		n2id = dict()
		for symbol_lo1_name in symbol_lo1_nodes:
			symbol_lo1 = nodes[symbol_lo1_name]
			n2id['lo1'] = symbol_lo1_name
			if symbol_lo1.sType == 'LCTN':
				for symbol_lo2_name in symbol_lo2_nodes:
					symbol_lo2 = nodes[symbol_lo2_name]
					n2id['lo2'] = symbol_lo2_name
					if symbol_lo2.sType == 'LCTN' and symbol_lo2.name!=symbol_lo1.name:
						for symbol_ap_name in symbol_ap_nodes:
							symbol_ap = nodes[symbol_ap_name]
							n2id['ap'] = symbol_ap_name
							if symbol_ap.sType == 'ARPL' and symbol_ap.name!=symbol_lo1.name and symbol_ap.name!=symbol_lo2.name and [n2id["ap"],n2id["lo1"],"at"] in snode.graph.links:
								for symbol_airport_name in symbol_airport_nodes:
									symbol_airport = nodes[symbol_airport_name]
									n2id['airport'] = symbol_airport_name
									if symbol_airport.sType == 'ARPT' and symbol_airport.name!=symbol_lo1.name and symbol_airport.name!=symbol_lo2.name and symbol_airport.name!=symbol_ap.name and [n2id["lo1"],n2id["airport"],"has"] in snode.graph.links and [n2id["lo2"],n2id["airport"],"has"] in snode.graph.links:
										# At this point we meet all the conditions.
										# Insert additional conditions manually here if you want.
										# (beware that the code could be regenerated and you might lose your changes).
										stack2        = copy.deepcopy(stack)
										equivalences2 = copy.deepcopy(equivalences)
										r1 = self.FLYAIRPLANE_trigger(snode, n2id, stack2, equivalences2, copy.deepcopy(finishesCombo))
										c = copy.deepcopy(r1)
										if 'fina' in locals():
											c.history.append(finishesCombo)
										if len(stack2) > 0: c.stop = True
										ret.append(c)
										if len(stack2) > 0:
											# Set symbol for lo1...
											for equiv in equivalences2:
												if [me, 'lo1'] in equiv[0]:
													equiv[1] = symbol_lo1_name
											# Set symbol for lo2...
											for equiv in equivalences2:
												if [me, 'lo2'] in equiv[0]:
													equiv[1] = symbol_lo2_name
											# Set symbol for ap...
											for equiv in equivalences2:
												if [me, 'ap'] in equiv[0]:
													equiv[1] = symbol_ap_name
											# Set symbol for airport...
											for equiv in equivalences2:
												if [me, 'airport'] in equiv[0]:
													equiv[1] = symbol_airport_name
											newNode = WorldStateHistory(r1)
											global lastNodeId
											lastNodeId += 1
											newNode.nodeId = lastNodeId
											newNode.parentId = snode.nodeId
											derivsx = self.getRules()[stack2[-1][1]](newNode, stack2, equivalences2)
											if 'fina' in locals():
												for n in derivsx: n.history.append(finishesCombo)
												for n in derivsx: n.history.append(fina)
											ret.extend(derivsx)
		return ret
		
		

	# Rule FLYAIRPLANE
	def FLYAIRPLANE_trigger(self, snode, n2id, stack=[], equivalences=[], checked=True, finish=''):
		if not checked:
			test_symbol_lo1 = snode.graph.nodes[n2id['lo1']]
			if not (test_symbol_lo1.sType == 'LCTN'):
				raise WrongRuleExecution('FLYAIRPLANE_trigger1 ')
			test_symbol_lo2 = snode.graph.nodes[n2id['lo2']]
			if not (test_symbol_lo2.sType == 'LCTN' and test_symbol_lo2.name!=test_symbol_lo1.name):
				raise WrongRuleExecution('FLYAIRPLANE_trigger2 ')
			test_symbol_ap = snode.graph.nodes[n2id['ap']]
			if not (test_symbol_ap.sType == 'ARPL' and test_symbol_ap.name!=test_symbol_lo1.name and test_symbol_ap.name!=test_symbol_lo2.name and [n2id["ap"],n2id["lo1"],"at"] in snode.graph.links):
				raise WrongRuleExecution('FLYAIRPLANE_trigger3 ')
			test_symbol_airport = snode.graph.nodes[n2id['airport']]
			if not (test_symbol_airport.sType == 'ARPT' and test_symbol_airport.name!=test_symbol_lo1.name and test_symbol_airport.name!=test_symbol_lo2.name and test_symbol_airport.name!=test_symbol_ap.name and [n2id["lo1"],n2id["airport"],"has"] in snode.graph.links and [n2id["lo2"],n2id["airport"],"has"] in snode.graph.links):
				raise WrongRuleExecution('FLYAIRPLANE_trigger4 ')
		smap = copy.deepcopy(n2id)
		newNode = WorldStateHistory(snode)
		global lastNodeId
		lastNodeId += 1
		newNode.nodeId = lastNodeId
		newNode.parentId = snode.nodeId
		# Create nodes
		# Retype nodes
		# Remove nodes
		newNode.graph.removeDanglingEdges()
		# Remove links
		newNode.graph.links = [x for x in newNode.graph.links if [x.a, x.b, x.linkType] not in [ [smap['ap'], smap['lo1'], 'at'] ]]
		# Create links
		l = AGMLink(smap['ap'], smap['lo2'], 'at')
		if not l in newNode.graph.links:
			newNode.graph.links.append(l)
		# Misc stuff
		newNode.probability *= 1.
		if len(stack) == 0:
			newNode.cost += 1
			newNode.depth += 1
		newNode.history.append('FLYAIRPLANE@' + str(n2id) )
		if finish!='': newNode.history.append(finish)
		return newNode
		
		
