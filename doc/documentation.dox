/**
\mainpage main page


\section intro_sec Introduction
<table border="0">
<tr>
<td>
<strong>AGM</strong> (Active Grammar-based modeling) is a modern core for robotic architectures capable of performing <strong>perception-aware planning</strong> (that means that, besides any regular planning-related task, you can use AGM to plan goals that involve detecting and modeling new objects). AGM relies on a visual language named <strong>AGGL</strong> (Active Graph Grammar Language) that is used describe the possible changes that robots can make to their world models and the behavior that they should adopt if such changes are desired. In conjunction with an AI planner, AGGL descriptions are used by AGM to reason about what to do depending on the robots' current goal and world model.

<strong>AGGL</strong> (Active Graph Grammar Language) is a powerful (yet easy to understand) visual language that is used describe the possible changes that robots can make to their world models and the behavior that they should adopt if such changes are desired. The description of these changes, expressed as graph-grammar rules, can be used for several purposes:

<ul>
<li>Generating plans to modify the world or the relationship between the robot and the world</li>
<li>Generating plans to perceive the world</li>
<li>Verifying world model modifications</li>
</ul>
</td>
<td>
<img src="AGGLEditor_B.png" width="700px">
</td>
</tr>
</table>

\section more_sec Read more
\ref agmworks
<br />
\ref components
<br />
\ref installation
<br />
\ref tutorials

**/



/**
\page agmworks How does AGM work?

In the context of AGM, behavior is the resulting phenomena of the coordinated interaction between the main modules of the architecture. In every AGM-based architecture, we can find three types of modules:
- a pool of <b><em>agents</em></b>, which are the modules that do the "real work" by interacting with the physical environment
- a <b><em>grammar-based controller</em></b>, in charge of controlling the agents and managing the robot's knowledge
- and a <b><em>planner</em></b>, which used by the controller to find plans and verify structural changes in the robot's knowledge

\image html wholePicture.png

Each grammar-based controller is composed of three elements:
- the current world <b><em>model</em></b>
- the <b><em>grammar</em></b> of the world, which is specified using the AGGL language
- the <b><em>mission</em></b> of the robot, which is also stored in a separate file
- and the <b><em>executive</em></b>, which is the software using or controlling the previous elements


AGM works as a loop where the beggining of each cycle is triggered by world model change proposals from one of the agents. When an agent which finishes performing an action, perceiving a new world element or any modification in the environment that should affect the robot's behavior, it proposes world model changes to the executive. These changes are verified by the executive and, if they are correct, the world model is updated (and broadcasted to all of the agents) and the plan is updated, entering in a loop in which AGM configure agents and, after performing some action or detecting the world model should be updated, these agents propose model changes.

AGM provides the executive and the planner. The rest of the elements of the architecture --the agents and the grammar-- is domain-dependent and depends on the tasks each robot is required to perform.


**/


/**
\page installation Installation

\tableofcontents

\section download Download

Despite we haven't made a release yet, the repository is quite stable and is unlikely to be broken. You can download a repository snapshot using this <a href="https://github.com/ljmanso/AGM/archive/master.zip">link</a> or clone the repository using a git client.
\code{.sh}
git clone git://github.com/ljmanso/AGM.git
\endcode

\section install Install

In addition the regular C++ requirements for the library, you will need to install some dependencies for the editor. Some of them are mandatory (PySide, pyparsing) and others are optional, depending on what you intend to do, specially if you want to export AGGL rules to PNG files (numpy, ImageOps). In Debian-based GNU/Linux distributions these dependencies can be installed using the following commands (as root):

Mandatory dependencies:
\code{.sh}
apt-get install cmake ppython python-pyside python-pyparsing
\endcode

Optional:
\code{.sh}
apt-get install python-numpy python-imaging
\endcode

Once the dependencies have been installed AGM and its associated applications can safely be installed using a script that allows users to select which optional features to activate (you can also run cmake-gui manually if you wish):

\code{.sh
sh compile.sh
\endcode

\section compilationproblems Common compilation problems

\section lackdeps Lack of dependencies

Lack of required dependencies is the most common issue when compiling, make sure you installed all of them. In case you are using a Debian-based distribution (and it's not very outdated) you can try running the instDep.sh script. Basically, the required dependencies are:

cmake
G++
Python
PyParsing
PySide
RoboComp: Optional. Required if it is desired to use AGM with RoboComp.
libboost-python: Optional. Required for libAGM Python bindings.

\section prevdecl Previous declaration of yyparse with C++ linkage

\code{.cpp}
agglparser.hpp:XXX:5: error: previous declaration of ‘int yyparse()’ with ‘C++’ linkage
\endcode

This seems to be caused by a bug in the bison version that comes with the latest Debian and Ubuntu. This is solved by editing aggllexer.l and agglparser.y, changing 'extern "C"' to 'extern'. In aggllexer you need to change:

\code{.cpp}
#define YY_DECL extern "C" int yylex()
\endcode

to

\code{.cpp}
#define YY_DECL extern int yylex()
\endcode

and, in agglparser.y:

\code{.cpp}
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
\endcode

to

\code{.cpp}
extern int yylex();
extern int yyparse();
extern FILE *yyin;
\endcode

**/



/**
\page executive AGM Executive

\tableofcontents


*/




/**
\page components What do I get with AGM?

\tableofcontents


The project is composed of four different elements:
<ul>
	<li>libAGM, the framework-agnostic library that is used to implement AGM executives (<strong>libagm</strong>).</li>
	<li>The AGGL visual editor (<strong>AGGLEditor</strong>).</li>
	<li>A problem visualizer (<strong>agm_xmlViewer</strong>).</li>
	<li>An AGGL to PDDL compiler (<strong>aggl2pddl</strong>).</li>
	<li>An PDDL problem generator (<strong>agm_xml2problem</strong>).</li>
	<li>The implementation of an executive designed to work with the <a href="http://robocomp.org">RoboComp framework</a> (<strong>RoboCompAGMExecutive</strong>).</li>
</ul>

\section compagm AGM library
The library that implements the core of AGM (libagm).

The API of the library is available here.

\section compaggleditor AGGL Visual editor
The visual editor, AGGLEditor, eases the process of designing grammars. It's use is described in its own page: \ref AGGLEditor.

\section compprobvisual Problem visualizer
Usage:
\code{.sh}
agm_xmlViewer initialWorld.xml goalPattern.xml
\endcode

\section compcompiler AGGL to PDDL domain compiler
Usage:
\code{.sh}
aggl2pddl -i grammar.aggl -p activeRules.pddl -f activeAndPassiveRules.pddl
\endcode

\section compproblemgen PDDL problem generator
Usage:
\code{.sh}
agm_xml2problem initialWorld.xml goal.xml problem.pddl [unknownMemorySize]
\endcode

\section compexecutive The AGM executive
There's a AGM executive that works with the <a href="http://robocomp.org">RoboComp</a> framework.

It is described in a separate page (\ref executive).

**/

/**
\page AGGLEditor AGGLEditor

\tableofcontents

\section AGGLEditor_intro Introduction

AGGLEditor is the tool that AGM provides for developing AGGL domain files.

\section AGGLEditor_why Why another language?

AGGLEditor is a visual editor for AGGL files. Writing graph-grammar rules in other languages such as PDDL can be daunting, specially if the context of the rule is of a considerable size. Take the following rule as an example:

\image html AGGLEditor.png

The corresponding PDDL code would be the following. It looks pretty nasty, right? You don't want to write that code manually. That's what AGGLEditor is for. We want to make designing graph grammars easier.

\code{.lisp}
(:action tellHumanAboutMug
                :parameters ( ?vc ?vsr ?vm ?vo ?vp ?vr ?vcont1 ?vcont2 ?vh ?vListAGMInternal ?vlist0 ?vlist1 ?vlist2 ?vlist3 ?vlist4 ?vlist5 ?vlist6 ?vlist7 )
                :precondition (and (ISclassified ?vc) (ISstatus ?vsr) (ISmug ?vm) (ISobject ?vo) (ISposition ?vp) (ISrobot ?vr) (ISobject ?vcont1) (ISobject ?vcont2) (IShuman ?vh) (firstunknown ?vlist7) (unknownorder ?vlist7 ?vlist6) (unknownorder ?vlist6 ?vlist5) (unknownorder ?vlist5 ?vlist4) (unknownorder ?vlist4 ?vlist3) (unknownorder ?vlist3 ?vlist2) (unknownorder ?vlist2 ?vlist1) (unknownorder ?vlist1 ?vlist0) (unknownorder ?vlist0 ?vListAGMInternal) (diff ?vo ?vcont1) (diff ?vo ?vcont2) (diff ?vcont1 ?vcont2) (diff ?vListAGMInternal ?vlist0) (diff ?vListAGMInternal ?vlist1) (diff ?vListAGMInternal ?vlist2) (diff ?vListAGMInternal ?vlist3) (diff ?vListAGMInternal ?vlist4) (diff ?vListAGMInternal ?vlist5) (diff ?vListAGMInternal ?vlist6) (diff ?vListAGMInternal ?vlist7) (diff ?vlist0 ?vlist1) (diff ?vlist0 ?vlist2) (diff ?vlist0 ?vlist3) (diff ?vlist0 ?vlist4) (diff ?vlist0 ?vlist5) (diff ?vlist0 ?vlist6) (diff ?vlist0 ?vlist7) (diff ?vlist1 ?vlist2) (diff ?vlist1 ?vlist3) (diff ?vlist1 ?vlist4) (diff ?vlist1 ?vlist5) (diff ?vlist1 ?vlist6) (diff ?vlist1 ?vlist7) (diff ?vlist2 ?vlist3) (diff ?vlist2 ?vlist4) (diff ?vlist2 ?vlist5) (diff ?vlist2 ?vlist6) (diff ?vlist2 ?vlist7) (diff ?vlist3 ?vlist4) (diff ?vlist3 ?vlist5) (diff ?vlist3 ?vlist6) (diff ?vlist3 ?vlist7) (diff ?vlist4 ?vlist5) (diff ?vlist4 ?vlist6) (diff ?vlist4 ?vlist7) (diff ?vlist5 ?vlist6) (diff ?vlist5 ?vlist7) (diff ?vlist6 ?vlist7) (know ?vr ?vo) (interacting ?vr ?vh) (link ?vsr ?vp) (has ?vo ?vsr) (link ?vsr ?vc) (link ?vsr ?vm) (in ?vsr ?vcont1) (eq ?vcont1 ?vcont2) )
                :effect (and (not (firstunknown ?vlist7)) (not (unknownorder ?vlist7 ?vlist6)) (not (unknownorder ?vlist6 ?vlist5)) (not (unknownorder ?vlist5 ?vlist4)) (not (unknownorder ?vlist4 ?vlist3)) (not (unknownorder ?vlist3 ?vlist2)) (not (unknownorder ?vlist2 ?vlist1)) (not (unknownorder ?vlist1 ?vlist0)) (not (unknownorder ?vlist0 ?vListAGMInternal)) (firstunknown ?vListAGMInternal) (ISclassified ?vlist7) (ISobject ?vlist6) (ISreach ?vlist5) (ISsee ?vlist4) (ISmug ?vlist3) (ISstatus ?vlist2) (ISreachable ?vlist1) (ISposition ?vlist0) (link ?vlist2 ?vlist7) (link ?vlist2 ?vlist1) (eq ?vo ?vlist6) (link ?vlist2 ?vlist0) (know ?vh ?vlist6) (in ?vlist2 ?vcont2) (has ?vlist6 ?vlist2) (link ?vlist2 ?vlist3) (link ?vlist2 ?vlist5) (link ?vlist2 ?vlist4) (increase (total-cost) 1) )
        )
\endcode


\section AGGLEditor_us_cr Create & save AGGL files
As in most programs with a user interface, there is a open and a save option in the 'File' section of the main menu. Unless a grammar file is specified as the first argument of the program (case in which such file is opened), it starts with an empty grammar.

\section AGGLEditor_us_crru Create & delete rules
In the main menu of the editor, select the corresponding option to create or delete rules. It also lets users to rename rules. In the case of deletion or renaming, the operation will be applied to the rule currently selected.

\section AGGLEditor_us_crsy Create delete & modify symbols
Creation, deletion and modification of symbols is performed selecting the corresponding option in the 'Tools' pan of the editor. The following operations can be applied to symbols:
- <b>add:</b> click on the position where it is desired to create a new symbol, whether in the area designed for the LHS or RHS
- <b>remove:</b> click over the symbol to be deleted
- <b>change type:</b> click over the symbol whose type is to be modified
- <b>move:</b> click over the symbol whose type is to be modified


\section AGGLEditor_us_cred Create, delete & modify edge labels
Creation, deletion and modification of the edges is performed selecting the corresponding option in the 'Tools' pan of the editor. The following operations can be applied to edges:
- <b>add:</b> press the left button of the mouse in the source node of the edge and release the button in the destination node
- <b>remove:</b> click over the label of the edge to be deleted
- <b>edit an edge's label:</b> click over the label to be modified


\section AGGLEditor_generatePDDL Generate PDDL code
In case you want to use a PDDL planner you can export the grammar to PDDL using the option 'Tools' -> 'Generate PDDL domain' in the main menu of the program. You will be asked for two file names. The first file (FULL) will contain the whole set of rules (it is supposed to be used for model verification purposes), the second file will contain only active rules (it is supposed to be used for regular planning pruposes).

\section AGGLEditor_generatePNG Export rules to PNG or SVG
To document how your robot works, or to share your domain definition with others as image files, the AGGL editor allows you to export the grammar to PNG or SVG files. To do this, select the corresponding tool within the 'Tools' section of the main menu.

**/


/**
\page tutorials Tutorials

 - The concept behind AGM: \ref agmworks "how does it work?"
 - What do I get with AGM? \ref components "AGM components"
 - How to install AGM: \ref installation "AGM installation"
 - Creating an AGGL domain: \ref AGGLEditor "using aggleditor"
 - How to use AGM in a robot: \ref executive "the AGM executive"

*/

