/**
\mainpage main page


\section intro_sec Introduction
AGM (Active Grammar-based modeling) is a modern core for <strong>perception-aware robotic architectures</strong>. It relies on a visual language named AGGL (Active Graph Grammar Language) that is used describe the possible changes that robots can make to their world models and the behavior that they should adopt if such changes are desired. In conjunction with an AI planner, AGGL descriptions are used by AGM to reason about what to do depending on the current objectives and world model.

AGGL (Active Graph Grammar Language) is a powerful (yet easy to understand) visual language visual language that is used describe the possible changes that robots can make to their world models and the behavior that they should adopt if such changes are desired. The description of these changes, expressed as graph-grammar rules, can be used for several purposes:

<ul>
<li>Generating plans to perceive the world</li>
<li>Generating plans to modify the world or the relationship between the robot and the world</li>
<li>Verifying world model modifications</li>
</ul>


\section more_sec Read more
\ref components
<br />
\ref installation
<br />
\ref agmworks
<br />
\ref executive

**/



/**
\page agmworks How does AGM work?

In the context of AGM, a behavior is the resulting phenomena of the coordinated interaction between the main modules of the architecture. These modules eventually propose world model changes to the executive, entering in a loop in which AGM activates some modules and --after a modeling or performing some action-- these modules propose model changes.


**/


/**
\page installation Installation

\tableofcontents

\section download Download

Despite we haven't made a release yet, the repository is quite stable and is unlikely to be broken. You can download a repository snapshot using this <a href="https://github.com/ljmanso/AGM/archive/master.zip">link</a> or clone the repository using a git client (url: git://github.com/ljmanso/AGM.git).

\section install Install

In addition the regular C++ requirements for the library, you will need to install some dependencies for the editor. Some of them are mandatory (PySide, pyparsing) and others are optional, depending on what you intend to do, specially if you want to export AGGL rules to PNG files (numpy, ImageOps). In Debian-based GNU/Linux distributions these dependencies can be installed using the following commands (as root):

Mandatory dependencies: 
\code{.sh}
apt-get install cmake ppython python-pyside python-pyparsing
\endcode

Optional:
\code{.sh}
apt-get install python-numpy python-imaging
\endcode

Once the dependencies have been installed AGM and its associated applications can safely be installed using a script that allows users to select which optional features to activate (you can also run cmake-gui manually if you wish):

sh compile

\section compilationproblems Common compilation problems

\section lackdeps Lack of dependencies

Lack of required dependencies is the most common issue when compiling, make sure you installed all of them. In case you are using a Debian-based distribution (and it's not very outdated) you can try running the instDep.sh script. Basically, the required dependencies are:

cmake
G++
Python
PyParsing
PySide
RoboComp: Optional. Required if it is desired to use AGM with RoboComp.
libboost-python: Optional. Required for libAGM Python bindings.

\section prevdecl Previous declaration of yyparse with C++ linkage

\code{.cpp}
agglparser.hpp:XXX:5: error: previous declaration of ‘int yyparse()’ with ‘C++’ linkage
\endcode

This seems to be caused by a bug in the bison version that comes with the latest Debian and Ubuntu. This is solved by editing aggllexer.l and agglparser.y, changing 'extern "C"' to 'extern'. In aggllexer you need to change:

\code{.cpp}
#define YY_DECL extern "C" int yylex()
\endcode

to

\code{.cpp}
#define YY_DECL extern int yylex()
\endcode

and, in agglparser.y:

\code{.cpp}
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
\endcode

to

\code{.cpp}
extern "C" int yylex();
extern "C" int yyparse();
extern "C" FILE *yyin;
\endcode

**/



/**
\page executive AGM Executive

\tableofcontents


*/




/**
\page components What do I get with AGM?

\tableofcontents


The project is composed of four different elements:
<ul>
	<li>libAGM, the framework-agnostic library that is used to implement AGM executives (<strong>libagm</strong>).</li>
	<li>The AGGL visual editor (<strong>AGGLEditor</strong>).</li>
	<li>A problem visualizer (<strong>agm_xmlViewer</strong>).</li>
	<li>An AGGL to PDDL compiler (<strong>aggl2pddl</strong>).</li>
	<li>An PDDL problem generator (<strong>agm_xml2problem</strong>).</li>
	<li>The implementation of an executive designed to work with the <a href="http://robocomp.org">RoboComp framework</a> (<strong>RoboCompAGMExecutive</strong>).</li>
</ul>

\section compagm AGM library
The library that implements the core of AGM (libagm).

The API of the library is available here.

\section compaggleditor AGGL Visual editor
The visual editor, AGGLEditor, eases the process of designing grammars. It's use is described in its own page: \ref AGGLEditor.

\section compprobvisual Problem visualizer
agm_xmlViewer initialWorld.xml goalPattern.xml

\section compcompiler AGGL to PDDL domain compiler
aggl2pddl -i grammar.aggl -p activeRules.pddl -f activeAndPassiveRules.pddl

\section compproblemgen PDDL problem generator
agm_xml2problem initialWorld.xml goal.xml problem.pddl [unknownMemorySize]

\section compexecutive The AGM executive
There's a AGM executive that works with the RoboComp framework.

It is described in a separate page (\ref executive).

**/

/**
\page AGGLEditor AGGLEditor

\tableofcontents

\section AGGLEditor_intro Introduction

AGGLEditor is the tool that AGM provides for developing AGGL domain files.

\section AGGLEditor_why Why another language?

AGGLEditor is a visual editor for AGGL files. Writing graph-grammar rules in other languages such as PDDL can be daunting, specially if the context of the rule is of a considerable size. Take the following rule as an example:

\image html AGGLEditor.png

The corresponding PDDL code would be the following. Looks pretty nasty right? You don't want to write that code manually. That's what AGGLEditor is for. We want to make designing graph grammars easier.

\code{.lisp}
(:action tellHumanAboutMug
                :parameters ( ?vc ?vsr ?vm ?vo ?vp ?vr ?vcont1 ?vcont2 ?vh ?vListAGMInternal ?vlist0 ?vlist1 ?vlist2 ?vlist3 ?vlist4 ?vlist5 ?vlist6 ?vlist7 )
                :precondition (and (ISclassified ?vc) (ISstatus ?vsr) (ISmug ?vm) (ISobject ?vo) (ISposition ?vp) (ISrobot ?vr) (ISobject ?vcont1) (ISobject ?vcont2) (IShuman ?vh) (firstunknown ?vlist7) (unknownorder ?vlist7 ?vlist6) (unknownorder ?vlist6 ?vlist5) (unknownorder ?vlist5 ?vlist4) (unknownorder ?vlist4 ?vlist3) (unknownorder ?vlist3 ?vlist2) (unknownorder ?vlist2 ?vlist1) (unknownorder ?vlist1 ?vlist0) (unknownorder ?vlist0 ?vListAGMInternal) (diff ?vo ?vcont1) (diff ?vo ?vcont2) (diff ?vcont1 ?vcont2) (diff ?vListAGMInternal ?vlist0) (diff ?vListAGMInternal ?vlist1) (diff ?vListAGMInternal ?vlist2) (diff ?vListAGMInternal ?vlist3) (diff ?vListAGMInternal ?vlist4) (diff ?vListAGMInternal ?vlist5) (diff ?vListAGMInternal ?vlist6) (diff ?vListAGMInternal ?vlist7) (diff ?vlist0 ?vlist1) (diff ?vlist0 ?vlist2) (diff ?vlist0 ?vlist3) (diff ?vlist0 ?vlist4) (diff ?vlist0 ?vlist5) (diff ?vlist0 ?vlist6) (diff ?vlist0 ?vlist7) (diff ?vlist1 ?vlist2) (diff ?vlist1 ?vlist3) (diff ?vlist1 ?vlist4) (diff ?vlist1 ?vlist5) (diff ?vlist1 ?vlist6) (diff ?vlist1 ?vlist7) (diff ?vlist2 ?vlist3) (diff ?vlist2 ?vlist4) (diff ?vlist2 ?vlist5) (diff ?vlist2 ?vlist6) (diff ?vlist2 ?vlist7) (diff ?vlist3 ?vlist4) (diff ?vlist3 ?vlist5) (diff ?vlist3 ?vlist6) (diff ?vlist3 ?vlist7) (diff ?vlist4 ?vlist5) (diff ?vlist4 ?vlist6) (diff ?vlist4 ?vlist7) (diff ?vlist5 ?vlist6) (diff ?vlist5 ?vlist7) (diff ?vlist6 ?vlist7) (know ?vr ?vo) (interacting ?vr ?vh) (link ?vsr ?vp) (has ?vo ?vsr) (link ?vsr ?vc) (link ?vsr ?vm) (in ?vsr ?vcont1) (eq ?vcont1 ?vcont2) )
                :effect (and (not (firstunknown ?vlist7)) (not (unknownorder ?vlist7 ?vlist6)) (not (unknownorder ?vlist6 ?vlist5)) (not (unknownorder ?vlist5 ?vlist4)) (not (unknownorder ?vlist4 ?vlist3)) (not (unknownorder ?vlist3 ?vlist2)) (not (unknownorder ?vlist2 ?vlist1)) (not (unknownorder ?vlist1 ?vlist0)) (not (unknownorder ?vlist0 ?vListAGMInternal)) (firstunknown ?vListAGMInternal) (ISclassified ?vlist7) (ISobject ?vlist6) (ISreach ?vlist5) (ISsee ?vlist4) (ISmug ?vlist3) (ISstatus ?vlist2) (ISreachable ?vlist1) (ISposition ?vlist0) (link ?vlist2 ?vlist7) (link ?vlist2 ?vlist1) (eq ?vo ?vlist6) (link ?vlist2 ?vlist0) (know ?vh ?vlist6) (in ?vlist2 ?vcont2) (has ?vlist6 ?vlist2) (link ?vlist2 ?vlist3) (link ?vlist2 ?vlist5) (link ?vlist2 ?vlist4) (increase (total-cost) 1) )
        )
\endcode


\section AGGLEditor_us_cr Create & save AGGL files
a
\subsection AGGLEditor_us_cr_cr Create
a
\subsection AGGLEditor_us_cr_sa Save

\section AGGLEditor_us_crru Create & delete rules
d
\subsection AGGLEditor_us_crru_cr Create
d
\subsection AGGLEditor_us_crru_de Delete
d

\section AGGLEditor_us_crsy Create delete & modify symbols
f
\subsection AGGLEditor_us_crsy_cr Create symbol
f
\subsection AGGLEditor_us_crsy_de Delete symbol
f
\subsection AGGLEditor_us_crsy_na Changing name
ff
\subsection AGGLEditor_us_crsy_ty Changing type
ff

\section AGGLEditor_us_cred Create, delete & modify edge labels
f
\subsection AGGLEditor_us_cred_cr Create edge
f
\subsection AGGLEditor_us_cred_de Delete edge
f
\subsection AGGLEditor_us_cred_mo Edit label
f


\section AGGLEditor_generatePDDL Generate PDDL code
In case you want to use a PDDL planner...

Generate PDDL code (full, active).

\section AGGLEditor_generatePNG Export rules to PNG

Export


**/



/**
\page commontasks Common tasks when using AGM
\tableofcontents

\section creating Creating a modeling
doc doc doc

\section modifying Making a structural modification to a model
Este código borra el símbolo de identificador cero e introduce dos símbolos en su lugar. Es pues un cambio estructural:


\code{.cpp}
// Create a new copy of the model
AGMModel::SPtr newModel(new AGMModel(worldModel));
// Create two symbols
AGMModelSymbol::SPtr robot  = newModel->newSymbol("robot");
AGMModelSymbol::SPtr status = newModel->newSymbol("status");
// Create a link
AGMModelEdge edge(robot->identifier, status->identifier, "bored");
newModel->edges.push_back(edge);
// Remove symbol
newModel->removeSymbol(0);
// Create a modification event with the previous and proposed model
RoboCompAGMWorldModel::Event e;
e.sender = "balltracker";
e.why = RoboCompAGMWorldModel::BehaviorBasedModification;
AGMModelConverter::fromInternalToIce(worldModel, e.backModel);
AGMModelConverter::fromInternalToIce(newModel, e.newModel);
try { agmagenttopic->modificationProposal(e);}
catch(const Ice::Exception &e) { std::cout << e << std::endl;};
\endcode

Como resultado, este código publica una propuesta de modificación que capturará el ejecutivo. Si se desarrolla un componente que haga muchos cambios es posible que sea conveniente meter las últimas siete líneas dentro de una función.


\section update Updating a symbol
Las actualización de un nodo es más sencilla:

\code{.cpp}
// Modify the attributes in the current model
worldModel->symbols[ballIndex]->attributes["x"] = xPos;
worldModel->symbols[ballIndex]->attributes["y"] = yPos;
worldModel->symbols[ballIndex]->attributes["z"] = zPos;
// Fill a RoboCompAGMWorldModel::Node structure with
// the new data.
RoboCompAGMWorldModel::Node node;
AGMModelConverter::fromInternalToIce(worldModel->symbols[ballIndex], node);
// Publish the proposal
try { agmagenttopic->update(node); }
catch(const Ice::Exception &e) { cout << e << endl; }
\endcode


\section print Printing a model
Da igual que sea un AGMModel::Sptr o la versión Ice del tipo de datos, usaremos la misma función:

\code{.cpp}
AGMModelPrinter::printWorld(model);
\endcode   

**/

